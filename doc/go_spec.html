<!--{
	"Title": "Go编程语言规范",
	"Subtitle": "2020年1月14日版本",
	"Path": "/ref/spec"
}-->

<h2 id="Introduction">介绍</h2>

<p>
	这是 Go 编程语言的参考手册。访问 <a href="/">golang.org</a> 来获取更多的信息及其他文档。
</p>

<p>
	Go 是一种在设计时就考虑了系统编程的通用语言。
	它是强类型的、具有垃圾回收功能且明确支持了并发编程。
	程序是由<i>包</i> 来构建的，<i>包</i> 的特性允许其高效的管理依赖关系。
</p>

<p>
	语法紧凑且易于解析，可通过集成开发环境等自动工具轻松进行分析。
</p>

<h2 id="Notation">标记法</h2>
<p>
	标记法语法指定使用扩展的巴科斯-瑙尔范式（EBNF）：
</p>

<pre class="grammar">
Production  = production_name "=" [ Expression ] "." .
Expression  = Alternative { "|" Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ "…" token ] | Group | Option | Repetition .
Group       = "(" Expression ")" .
Option      = "[" Expression "]" .
Repetition  = "{" Expression "}" .
</pre>

<p>
	产生式（Productions）是由术语（terms）和如下操作符所构成的表达式，其优先级越来越高：
</p>
<pre class="grammar">
|   选择
()  分组
[]  决择
{}  重复
</pre>

<p>
	小写字母的产生式名用于标识词汇（词组）记号的。
	非终结符（Non-terminals）是以驼峰的形式命名的。
	词汇记号用双引号 <code>""</code> 或反引号 <code>``</code>。
</p>

<p>
	<code>a … b </code>这样的格式表示从 <code>a</code> 到 <code>b</code> 的连续字符集。
	在规范中的其他地方也会使用水平省略号 <code>…</code> 来非正式地表示各种枚举或代码段，而这些代码段未作进一步规定。
	字符 <code>…</code>（与单独的三个字符 <code>...</code> 不同），并不是 Go 语言的标记。
</p>

<h2 id="Source_code_representation">源代码表示</h2>

<p>
	源代码是采用 <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> 编码的 Unicode 文本。
	该文本并不是规范化的，所以一个单字节字符集的码位（code point）和由单字节字符集和字母组成的相同字符不同；后者被视为是两个码位。
	为简单起见，本文档使用非正规的术语 <i>字符</i> 来指代源文本中的 Unicode 码位。
</p>
<p>
	每个码位都是不同的；例如，大写和小写字母是不同的字符。
</p>
<p>
	实现限制：为了与其他工具兼容，编译器可能会禁止在源文本中使用 NUL 字符（U+0000）。
</p>
<p>
	实现限制：为了与其他工具兼容，如果一个 UTF-8 编码的字节顺序标记（U+FEFF）为源文本的第一个 Unicode 码位，编译器可能会忽略它。
	字节顺序标记也可能会禁止在源中的任何其它位置使用。
</p>

<h3 id="Characters">字符</h3>

<p>
	如下述术语用于表示特定的 Unicode 字符类：
</p>
<pre class="ebnf">
newline        = /* 换行（LF）的 Unicode 码位为 U+000A */ .
unicode_char   = /* 除换行符外的任意 Unicode 码位 */ .
unicode_letter = /* 分类为“字母”的 Unicode 码位 */ .
unicode_digit  = /* 分类为“数字，十进制数字”的 Unicode 码位 */ .
</pre>

<p>
	在 <a href="https://www.unicode.org/versions/Unicode8.0.0/">Unicode 8.0 标准中</a>，第4.5节 "General Category" 定义了一套字符类别。
	Go将字母类别 Lu，Ll，Lt，Lm 或 Lo 中的任何字符视为 Unicode 字母，将数字类别 Nd 中的所有字符视为 Unicode 数字。
</p>

<h3 id="Letters_and_digits">字母和数字</h3>

<p>
	下划线字符 <code>_</code> (U+005F) 被认为是一个字母.
</p>
<pre class="ebnf">
letter        = unicode_letter | "_" .
decimal_digit = "0" … "9" .
binary_digit  = "0" | "1" .
octal_digit   = "0" … "7" .
hex_digit     = "0" … "9" | "A" … "F" | "a" … "f" .
</pre>

<h2 id="Lexical_elements">词法单元</h2>

<h3 id="Comments">注释</h3>

<p>
	注释作为程序的文档，有以下两种形式：
</p>

<ol>
<li>
<i>单行注释</i> 以字符序列 <code>//</code> 开头并在该行的结尾处停止。
</li>
<li>
<i>全局注释</i> 以字符序列 <code>/*</code> 开头并在遇到第一个字符序列  <code>*/</code> 时结束。
</li>
</ol>

<p>
注释不能开始于 <a href="#Rune_literals">rune</a> 或 <a href="#String_literals">string 字面量（literal）</a>或另一个注释的内部。不包含换行符的注释就像一个空格。任何其他的注释都像一个换行符。
</p>

<h3 id="Tokens">Tokens</h3>

<p>
	Tokens 组成了 Go 语言的词汇表。有四个分类：<i>标识符</i>，<i>关键字</i>，<i>运算符和标点符号</i>，和<i>字面量</i>。
	<i>空白</i> 是由空格（U+0020），水平制表符（U+0009），回车符（U+000D）以及换行符（U+000A）所组成的，空白一般会被忽略，因为它会分隔标记，否则将合并为一个 tokens。
	另外，换行符或文件结尾可能会触发<a href="#Semicolons">分号</a>的插入。
	把输入的内容区分为 tokens 时，每一个 token 都是可组成有效 token 的最长字符序列。
</p>

<h3 id="Semicolons">分号</h3>

<p>
	正式的语法使用分号 <code>";"</code> 作为一些产生式的终止符。
	Go 程序可以使用以下两个规则来省略大多数这样的分号：
</p>

<ol>
<li>
	当输入的内容被分解为 tokens 时，当每一行最后一个 token 为以下 token 时，一个分号会自动插入到其后面：
<ul>
	<li>一个
	    <a href="#Identifiers">标识符</a>
	</li>

	<li>一个
	    <a href="#Integer_literals">整形</a>,
	    <a href="#Floating-point_literals">浮点数</a>,
	    <a href="#Imaginary_literals">虚数</a>,
	    <a href="#Rune_literals">rune</a>, 或者
	    <a href="#String_literals">字符串</a> 字面量
	</li>

	<li> <a href="#Keywords">关键字</a>
	    <code>break</code>,
	    <code>continue</code>,
	    <code>fallthrough</code>, 或者
	    <code>return</code> 之一
	</li>

	<li> <a href="#Operators_and_punctuation">运算符和标点符号</a>
	    <code>++</code>,
	    <code>--</code>,
	    <code>)</code>,
	    <code>]</code>, 或者
	    <code>}</code> 之一
	</li>
</ul>
</li>

<li>
	为了使复杂的语句占据一行，分号可以在结束 <code>")"</code> 或 <code>"}"</code> 之前省略。
</li>
</ol>

<p>
	为了反映惯用用法，本文档中的代码示例使用这些规则来省略分号。
</p>


<h3 id="Identifiers">标识符</h3>

<p>
	标识符命名程序中的实体，例如变量和类型。
	标识符是一个或多个字母或数字的组合。
	标识符的第一个字符必须是字母。
</p>
<pre class="ebnf">
identifier = letter { letter | unicode_digit } .
</pre>
<pre>
a
_x9
ThisVariableIsExported
αβ
</pre>

<p>
	一些标识符是<a href="#Predeclared_identifiers">预先声明的</a>。
</p>


<h3 id="Keywords">关键字</h3>

<p>
	以下关键字是保留关键字，不能用作标识符。
</p>
<pre class="grammar">
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
</pre>

<h3 id="Operators_and_punctuation">运算符和标点符号</h3>

<p>
	以下字符序列表示<a href="#Operators">运算符</a>（包括<a href="#assign_op">赋值运算符</a>）和标点符号:
</p>
<pre class="grammar">
+    &amp;     +=    &amp;=     &amp;&amp;    ==    !=    (    )
-    |     -=    |=     ||    &lt;     &lt;=    [    ]
*    ^     *=    ^=     &lt;-    &gt;     &gt;=    {    }
/    &lt;&lt;    /=    &lt;&lt;=    ++    =     :=    ,    ;
%    &gt;&gt;    %=    &gt;&gt;=    --    !     ...   .    :
     &amp;^          &amp;^=
</pre>

<h3 id="Integer_literals">整型字面量</h3>

<p>
	整型字面量是用来代表<a href="#Constants">整型常量</a>的数字序列。
	可用一个可选的前缀来设置非十进制数：<code>0b</code> 或 <code>0B</code> 代表二进制，<code>0</code>，<code>0o</code>，或 <code>0O</code> 代表八进制，<code>0x</code> 或 <code>0X</code> 代表十六进制。
	单独的 <code>0</code> 被认为是十进制零。
	在十六进制数的字面量中，字母 <code>a</code> 到 <code>f</code> 和 <code>A</code> 到 <code>F</code> 代表数值 10 到 15。
</p>

<p>
	为了便于阅读，下划线字符 <code>_</code> 可能出现在基本前缀之后或连续数字之间；
	这样的下划线不会更改字面量的值。
</p>
<pre class="ebnf">
int_lit        = decimal_lit | binary_lit | octal_lit | hex_lit .
decimal_lit    = "0" | ( "1" … "9" ) [ [ "_" ] decimal_digits ] .
binary_lit     = "0" ( "b" | "B" ) [ "_" ] binary_digits .
octal_lit      = "0" [ "o" | "O" ] [ "_" ] octal_digits .
hex_lit        = "0" ( "x" | "X" ) [ "_" ] hex_digits .

decimal_digits = decimal_digit { [ "_" ] decimal_digit } .
binary_digits  = binary_digit { [ "_" ] binary_digit } .
octal_digits   = octal_digit { [ "_" ] octal_digit } .
hex_digits     = hex_digit { [ "_" ] hex_digit } .
</pre>

<pre>
42
4_2
0600
0_600
0o600
0O600       // second character is capital letter 'O'
0xBadFace
0xBad_Face
0x_67_7a_2f_cc_40_c6
170141183460469231731687303715884105727
170_141183_460469_231731_687303_715884_105727

_42         // 这是一个标识符, 而不是一个整型字面量
42_         // 无效: _ 必须分隔连续数字
4__2        // 无效: 一次只能有一个 _
0_xBadFace  // 无效: _ 必须分隔连续数字
</pre>


<h3 id="Floating-point_literals">浮点数字面量</h3>

<p>
	浮点数字面量是<a href="#Constants">浮点数常量</a>的十进制或十六进制表示。
</p>

<p>
	十进制的浮点数字面量由整数部分（十进制数字），小数点，小数部分（十进制小数）和指数部分（<code>e</code> 或 <code>E</code> 后紧跟着带或者不带符号的十进制数字）组成。
	整数部分或小数部分其中之一可以被省略；小数点部分或指数部分其中之一可以被省略。
	指数值 exp 以 10<sup>exp</sup> 来缩放尾数（mantissa）（整数部分和小数部分）。
</p>

<p>
	十六进制浮点数字面量由一个 <code>0x</code> 或 <code>0X</code> 前缀，一个整数部分（十六进制数字），一个小数点，一个小数部分（十六进制小数），和一个指数部分（<code>p</code> 或 <code>P</code> 后紧跟着带或者不带符号的十六进制的数字）组成。
	整数部分或小数部分其中之一可以被省略；小数点也可以被省略，但是指数部分是必须的。（此语法与 IEEE 754-2008§5.12.3 中给出的语法匹配。）
	指数值 exp 以 2<sup>exp</sup> 来缩放尾数（mantissa）（整数部分和小数部分）。
</p>

<p>
	为了便于阅读，下划线字符 <code>_</code> 可能出现在基本前缀之后或连续数字之间；
	这样的下划线不会更改字面量的值。
</p>

<pre class="ebnf">
float_lit         = decimal_float_lit | hex_float_lit .

decimal_float_lit = decimal_digits "." [ decimal_digits ] [ decimal_exponent ] |
                    decimal_digits decimal_exponent |
                    "." decimal_digits [ decimal_exponent ] .
decimal_exponent  = ( "e" | "E" ) [ "+" | "-" ] decimal_digits .

hex_float_lit     = "0" ( "x" | "X" ) hex_mantissa hex_exponent .
hex_mantissa      = [ "_" ] hex_digits "." [ hex_digits ] |
                    [ "_" ] hex_digits |
                    "." hex_digits .
hex_exponent      = ( "p" | "P" ) [ "+" | "-" ] decimal_digits .
</pre>

<pre>
0.
72.40
072.40       // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
1_5.         // == 15.0
0.15e+0_2    // == 15.0

0x1p-2       // == 0.25
0x2.p10      // == 2048.0
0x1.Fp+0     // == 1.9375
0X.8p-0      // == 0.5
0X_1FFFP-16  // == 0.1249847412109375
0x15e-2      // == 0x15e - 2 (integer subtraction)

0x.p1        // 无效: 尾数（mantissa）没有数字
1p-2         // 无效: p 指数需要十六进制尾数
0x1.5e-2     // 无效: 十六进制尾数要求p指数
1_.5         // 无效: _ 必须分隔连续数字
1._5         // 无效: _ 必须分隔连续数字
1.5_e1       // 无效: _ 必须分隔连续数字
1.5e_1       // 无效: _ 必须分隔连续数字
1.5e1_       // 无效: _ 必须分隔连续数字
</pre>


<h3 id="Imaginary_literals">虚数字面量</h3>

<p>
	虚数字面量表示复数<a href="#Constants">常量</a>的虚部。
	它由一个<a href="#Integer_literals">整型</a>或<a href="#Floating-point_literals">浮点型</a>字面量紧跟着一个小写字母 <code>i</code> 组成。
	这个虚数字面量的值是相应整型或浮点型字面量的值乘以虚数的单位 <i>i</i>。
</p>

<pre class="ebnf">
imaginary_lit = (decimal_digits | int_lit | float_lit) "i" .
</pre>

<p>
	考虑到向后兼容，虚数字面量的整数部分完全由十进制数字（可能存在下划线）组成，即使其以 <code>0</code> 开头也不例外。
</p>

<pre>
0i
0123i         // == 123i for backward-compatibility
0o123i        // == 0o123 * 1i == 83i
0xabci        // == 0xabc * 1i == 2748i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i
0x1p-2i       // == 0x1p-2 * 1i == 0.25i
</pre>


<h3 id="Rune_literals">Rune 字面量</h3>

<p>
	一个 Rune 字面量代表一个 Rune <a href="#Constants">常量</a>，一个整确定了 Unicode 码位的整数值。
	Rune 字面量表示一个或多个用单引号括起来的字符，如 <code>'x'</code> 或 <code>'\n'</code>。
	在引号内，除换行符和未转义的单引号外，其它任何字符都可以出现。
	用单引号引起来的字符表示字符本身的Unicode值，而以反斜杠开头的多字符序列则以不同的格式来编码 Unicode 值。
</p>

<p>
	这是在引号内代表单一字符的最简单的形式；由于 Go 源文本是采用 UTF-8 编码的 Unicode 字符，因此多个 UTF-8 编码的字节可以表示单个整数值。
	例如，字面量 <code>'a'</code> 用一个单个字节代表一个字面量 <code>a</code>，Unicode U+0061，值为 <code>0x61</code>，但 <code>'ä'</code> 用了两个字节（<code>0xc3</code> <code>0xa4</code>）代表一个字面量 <code>a 分音符 </code>，U+00E4，值为 <code>0xe4</code>。
</p>

<p>
	多个反斜杠转义符允许将任意值编码为 ASCII 文本。
	有四种方法可以将整数值表示为数字常量：<code>\x</code> 后紧跟两个十六进制数；<code>\u</code> 后紧跟四个十六进制数；<code>\U</code> 后紧跟八个十六进制数；一个简单的反斜杠 <code>\</code> 后紧跟着三个八进制数。
	每一种情况的字面量的值都是相应的基数上该数所表示的值。
</p>

<p>
	虽然这些表示的结果都是一个整数，但它们具有不同的有效范围。
	八进制转义符必须表示一个 0 和 255 之间的值。
	十六进制转义满足条件的要求会因为构造不同而不同。
	转义字符 <code>\u</code> 和 <code>\U</code> 表示 Unicode 码位。因此其中有些值是非法的，尤其是那些大于 <code>0x10FFFF</code> 的值和替换了一半的。
</p>

<p>
	在反斜杠后，某些单字符的转义表示特殊的值：
</p>

<pre class="grammar">
\a   U+0007 响铃
\b   U+0008 退格
\f   U+000C 换页
\n   U+000A 换行
\r   U+000D 回车
\t   U+0009 水平制表
\v   U+000b 垂直制表
\\   U+005c 反斜杠
\'   U+0027 单引号  (仅在 rune 字面量内转义转义才有效)
\"   U+0022 双引号  (仅在字符串字面量中转义才有效)
</pre>

<p>
	所有其他以反斜杠开头的序列在 Rune 字面量中都是非法的。
</p>
<pre class="ebnf">
rune_lit         = "'" ( unicode_value | byte_value ) "'" .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` octal_digit octal_digit octal_digit .
hex_byte_value   = `\` "x" hex_digit hex_digit .
little_u_value   = `\` "u" hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` "U" hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
escaped_char     = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .
</pre>

<pre>
'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'
'\''         // rune 字面量包含单引号字符
'aa'         // 非法: 字符过多
'\xa'        // 非法: 十六进制数字过少
'\0'         // 非法: 十进制数字过少
'\uDFFF'     // 非法: 只替换了一半
'\U00110000' // 非法: 无效的 Unicode 码位
</pre>


<h3 id="String_literals">字符串字面量</h3>

<p>
	字符串字面量表示通过串联字符序列而获得的字符串常量<a href="#Constants">常量</a>。
	它有两种形式：原始类型字符串字面量和解释类型字符串字面量。
</p>

<p>
	原始类型字符串字面量是在反引号之间的字符序列，如 <code>`foo`</code>。
	除了反引号之外的任何字符都可以出现在该引号内。
	原始类型字符串字面量的值就是由在引号内未被解释过的（隐式 UTF-8 编码的）字符所组成的字符串；特别是，反斜杠没有特殊含义，它可能包含换行符。
	原始类型字符串字面量值中的回车符（'\r'）会被从原始类型字符串值中丢弃。
</p>

<p>
	解释类型字符串字面量是双引号之间的字符序列，如 <code>&quot;bar&quot;</code>。
	在引号内，除换行符和未转义的双引号外，任何字符都可能出现。
	引号之间的文本组成了字符串字面量的值，反斜杠的转义和限制与 <a href="#Rune_literals">rune</a> 字面量一样（不同的是，在解释型字符串字面量中，<code>\'</code> 是非法的，<code>\"</code> 是合法的）。
	三位八进制数（<code>\</code><i>nnn</i>）和两位十六进制数（<code>\x</code><i>nn</i>）的转义代表着所生成字符串的各个<i>字节</i>；
	所有其它的转义代表了单独<i>字符</i> 的 UTF-8 编码（可能是多字节的）。
	因此字符串字面量内的 <code>\377</code> 和 <code>\xFF</code> 代表着值为 <code>0xFF</code>=255 的单一字节，而 <code>ÿ</code>，<code>\u00FF</code>， <code>\U000000FF</code> 和 <code>\xc3\xbf</code> 代表着字符 U+00FF（以 UTF-8 编码的双字节 <code>0xc3</code> <code>0xbf</code>）
</p>

<pre class="ebnf">
string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = "`" { unicode_char | newline } "`" .
interpreted_string_lit = `"` { unicode_value | byte_value } `"` .
</pre>

<pre>
`abc`                // same as "abc"
`\n
\n`                  // same as "\\n\n\\n"
"\n"
"\""                 // same as `"`
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
"\uD800"             // 非法: 只替换了一半
"\U00110000"         // 非法: 无效的Unicode 码位
</pre>

<p>
	这些示例都表示相同的字符串：
</p>

<pre>
"日本語"                                 // UTF-8 输入文本
`日本語`                                 // UTF-8 输入文本作为一个原始类型字面量
"\u65e5\u672c\u8a9e"                    // 明确的 Unicode 码位
"\U000065e5\U0000672c\U00008a9e"        // 明确的 Unicode 码位
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // 明确的 UTF-8 字节
</pre>

<p>
	当源代码以两个码位表示一个字符，比如包含一个重音符号（accent）和一个字母的组合形式，如果是在 rune 字面量中的话会使得结果出错（因为其并不是一个单一码位），而如果是在字符串字面量中的话则会显示为两个码位。
</p>


<h2 id="Constants">常量</h2>

<p>
	常量有<i>布尔常量</i>，<i>rune 常量</i>，<i>整型常量</i>，<i>浮点数常量</i>，<i>复数常量</i>，和<i>字符串常量</i>。
	Rune，整型，浮点型，和复数常量统称为<i>数值常量</i>。
</p>

<p>
	一个常量的值由 <a href="#Rune_literals">rune</a>，<a href="#Integer_literals">整数</a>，<a href="#Floating-point_literals">浮点数</a>，<a href="#Imaginary_literals">虚数</a>或<a href="#String_literals">字符串</a>字面量所表示，表示常量的标识符，<a href="#Constant_expressions">常量表达式</a>，
<a href="#Conversions">转换</a>结果为常量，或者一些内置函数所生成的值如 <code>unsafe.Sizeof</code> 适用于任何值，<code>cap</code> 或 <code>len</code> 适用于<a href="#Length_and_capacity">一些表达式</a>，<code>real</code> 和 <code>imag</code> 适用于复数常量，以及 <code>complex</code>适用于数值常量。
	布尔值是由预先声明的常量 <code>true</code> 和 <code>false</code> 表示。
	预先声明的标识符 <a href="#Iota">iota</a> 表示一个整数常量。
</p>

<p>
	通常，复数常量是<a href="#Constant_expressions">常量表达式</a>的一种形式，将在该节讨论。
</p>

<p>
	数值常量表示任意精度的精确值，并且不会溢出。
	因此，没有常量表示 IEEE-754 负零，无穷大以及非数字值。
</p>

<p>
	常量可能是<a href="#Types">有类型的</a>或<i>无类型的</i>。
	字面量常量，<code>true</code>，<code>false</code>，<code>iota</code>，以及一些仅包含无类型的恒定操作数的<a href="#Constant_expressions">常量表达式</a>是无类型的。
</p>

<p>
	常量可以通过<a href="#Constant_declarations">常量声明</a>或<a href="#Conversions">转换</a>来显式地指定类型，也可以在<a href="#Variable_declarations">变量声明</a>或<a href="#Assignments">赋值</a>或作为<a href="#Expressions">表达式</a>中的操作数隐式地被赋予一个类型。
	如果常量值不能<a href="#Representability">表示</a>为相应类型的值，则会出错。
</p>

<p>
	一个无类型的常量有一个<i>默认类型</i>，该默认类型是在需要使用类型值的上下文中，比如像 <code>i := 0</code> 这样子的<a href="#Short_variable_declarations">简短的变量声明</a>就没有显式的类型。
	无类型常量的默认类型分别是 <code>bool</code>，<code>rune</code>，<code>int</code>，<code>float64</code>，<code>complex128</code> 或 <code>string</code>，取决于它是否是一个布尔值、rune、整数、浮点数、复数或字符串常量。
</p>

<p>
	实现限制：虽然数值常量在这个语言中可以是任意精度的，但编译器可能会使用精度受限的内部表示法来实现它。也就是说，每一种实现必须：
</p>

<ul>
	<li>使用至少256位表示整数常量。</li>

	<li>使用最少 256 位来表示浮点数常量（包括复数常量的对应部分）的小数部分，使用最少 16 位表示其带符号的二进制指数部分。</li>

	<li>当无法表示一个整数常量的精度时，需要给出错误。</li>

	<li>当因为溢出而无法表示一个浮点数或复数常量时，需要给出错误。</li>

	<li>当因为精度限制而无法表示一个浮点数或复数常量时，约到最接近的可表示的常量。</li>
</ul>

<p>
	这些要求既适用于字面量常量，也适用于<a href="#Constant_expressions">常量表达式</a>的求值结果。
</p>


<h2 id="Variables">变量</h2>

<p>
	变量是用于保存<i>值</i> 的存储位置。可允许的值的集是由变量<i><a href="#Types">类型</a></i> 所确定的。
</p>

<p>
	<a href="#Variable_declarations">变量声明</a>和对于函数参数及其结果而言的<a href="#Function_declarations">函数声明</a>或<a href="#Function_literals">函数字面量</a>的签名都为命名的变量保留存储空间。
	调用内置函数 <a href="#Allocation"><code>new</code></a> 或获取<a href="#Composite_literals">复合字面量</a>的地址会在运行时为变量分配存储空间。
	这样子的一个匿名变量是通过（可能隐式的）<a href="#Address_operators">指针间接</a>引用到的。
</p>

<p>
	<i>结构化</i> 的<a href="#Array_types">数组</a>，<a href="#Slice_types">切片</a>和<a href="#Struct_types">结构体</a>类型变量存在可以独立<a href="#Address_operators">寻址</a>的元素和字段。
	每一个这样子的元素就像一个变量。
</p>

<p>
	变量的<i>静态类型</i>（或者就叫<i>类型</i>）是其声明时确定好的类型，或由 <code>new</code> 调用或复合字面量所提供的类型，或结构化变量的元素类型。
	接口类型的变量还有一个独特的<i>动态</i> 类型，该类型是在运行时所分配给变量的值的具体类型（除非那个值是预声明的标识符<code>nil</code>，它是没有类型的）。
	动态类型可能会在执行过程中变化，但存储在接口变量中的值始终<a href="#Assignability">可分配</a>为接口变量的静态类型。
</p>

<pre>
var x interface{}  // x 是 nil，它有一个静态类型 interface{}
var v *T           // v 的值为 nil，静态类型为 *T
x = 42             // x 的值为 42，动态类型为 int
x = v              // x 的值为 (*T)(nil)，动态类型为 *T
</pre>

<p>
	变量的值是通过引用<a href="#Expressions">表达式</a>中的变量来检索的；它是<a href="#Assignments">分配</a>给变量的最新值。
	如果一个变量还没有被分配到值，那么它的值是其对应类型的<a href="#The_zero_value">零值</a>。
</p>


<h2 id="Types">类型</h2>

<p>
	类型确定一组值以及特定于那些值的操作和方法。
	类型可以是由<i>类型名</i> 所表示的（如果它有的话），或者使用<i>类型字面值</i> 指定,该类型字面量由现有类型组成。。
</p>

<pre class="ebnf">
Type      = TypeName | TypeLit | "(" Type ")" .
TypeName  = identifier | QualifiedIdent .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
	    SliceType | MapType | ChannelType .
</pre>

<p>
	语言本身<a href="#Predeclared_identifiers">预先声明</a>了一些特定的类型名。
	其它的命名类型则使用<a href="#Type_declarations">类型声明</a>引入。
	<i>复合类型</i> ——数组、结构体、指针、函数、接口、切片、映射和 channel 类型——可以由类型字面量构成。
</p>

<p>
	每个类型 <code>T</code> 都有一个<i>潜在类型</i>：如果 <code>T</code> 是预先声明的布尔值、数值或者字符串类型之一，或一个类型字面量，那对应的潜在类型就是 <code>T</code> 自己。
	否则，其潜在类型就是在<a href="#Type_declarations">类型声明</a>时 <code>T</code> 指定的那个类型的潜在类型。
</p>

<pre>
type (
	A1 = string
	A2 = A1
)

type (
	B1 string
	B2 B1
	B3 []B1
	B4 B3
)
</pre>

<p>
	<code>string</code>，<code>A1</code>，<code>A2</code>，<code>B1</code> 和 <code>B2</code> 的潜在类型是 <code>string</code>。
	<code>[]B1</code>，<code>B3</code> 和 <code>B4</code> 的潜在类型是 <code>[]B1</code>。
</p>

<h3 id="Method_sets">方法集</h3>
<p>
	一个类型可能有一个 <i>方法集（method set）</i>与之关联。
	<a href="#Interface_types">接口类型</a>的方法集就是它的接口。
	任何其它类型 <code>T</code> 的方法集由以类型 <code>T</code> 为接收者所声明的所有<a href="#Method_declarations">方法</a>组成。
	相应的<a href="#Pointer_types">指针类型</a> <code>*T</code> 的方法集是以 <code>*T</code> 或 <code>T</code> 为接收者所声明的所有方法的集合（也就是说，它同样包含了 <code>T</code> 的方法集）。
	适用于包含嵌入式字段结构的更多规则会在<a href="#Struct_types">结构体类型</a>部分中叙述。
	任何其它类型会有一个空的方法集。
	在一个方法集中，每一个方法必须要有一个<a href="#Uniqueness_of_identifiers">唯一的</a>非<a href="#Blank_identifier">空白</a>的<a href="#MethodName">方法名</a>。
</p>

<p>
	类型的方法集确定了这个类型所<a href="#Interface_types">实现</a>的接口和以此类型作为接收者所可以<a href="#Calls">调用</a>的方法。
</p>

<h3 id="Boolean_types">布尔类型</h3>

<p>
	<i>布尔类型</i> 代表以预先声明的常量 <code>true</code> 和 <code>false</code> 所表示的布尔真值的集合。
	预先声明的布尔类型为 <code>bool</code>；这是一个<a href="#Type_definitions">定义类型</a>。
</p>

<h3 id="Numeric_types">数字类型</h3>

<p>
	<i>数字类型</i> 代表整数或浮点数值的集合。
	预先声明的与体系结构无关的数字类型有：
</p>

<pre class="grammar">
uint8       无符号的  8 位整数集合 (0 to 255)
uint16      无符号的 16 位整数集合 (0 to 65535)
uint32      无符号的 32 位整数集合 (0 to 4294967295)
uint64      无符号的 64 位整数集合 (0 to 18446744073709551615)

int8        带符号的  8 位整数集合 (-128 to 127)
int16       带符号的  16 位整数集合 (-32768 to 32767)
int32       带符号的  32 位整数集合 (-2147483648 to 2147483647)
int64       带符号的  64 位整数集合 (-9223372036854775808 to 9223372036854775807)

float32     所有 IEEE-754 标准的 32 位浮点数数字集合
float64     所有 IEEE-754 标准的 64 位浮点数数字集合

complex64   由 float32 类型的实数和虚数部分所组成的所有复数的集合
complex128  由 float64 类型的实数和虚数部分所组成的所有复数的集合

byte        unit8 的别名
rune        int32 的别名
</pre>

<p>
	一个 <i>n</i> 位整数的值是 <i>n</i> 位宽的，是使用 <a href="https://en.wikipedia.org/wiki/Two's_complement">二进制补码</a>来表示的。
</p>

<p>
	以下是根据实现不同而有特定大小的预先声明的数字类型：
</p>

<pre class="grammar">
uint     可以是 32 或 64 位
int      和 uint 大小相同
uintptr  一个大到足够用来存储一个指针值的未解释的比特位的无符号整数
</pre>

<p>
	为了避免移植性问题，除了 <code>byte</code> （ <code>uint8</code> 的<a href="#Alias_declarations">别名）</a>和 <code>rune</code> （ <code>int32</code> 的别名）外的所有数字类型都是截然不同的<a href="#Type_definitions">定义类型</a>。
	当不同的数字类型混合在一个表达式或赋值里时，是需要显式的转换的。
	比如，<code>int32</code> 和 <code>int</code> 并不是相同的类型，就算在一个特定的架构上它们可能有相同的大小，也是如此。
</p>

<h3 id="String_types">字符串类型</h3>

<p>
	<i>字符串类型</i> 代表了字符串值的集合。
	一个字符串值是字节的序列（可能为空）。
	字节的个数被称为该字符串的长度，并且不能为负。
	字符串是不可变的：一旦创建好了是不可能去修改其内容的。
	预先声明的字符串类型是 <code>string</code>；它是一个<a href="#Type_definitions">定义类型</a>。
</p>

<p>
	字符串 <code>s</code> 的长度可以使用内置函数 <a href="#Length_and_capacity"><code>len</code></a> 获取到。
	如果字符串是一个常量，那么长度是一个编译时常量。
	一个字符串的字节可以通过整数<a href="#Index_expressions">索引</a> 0 到 <code>len(s)-1</code> 来访问。
	获取一个元素的地址是非法的；如果 <code>s[i]</code> 是一个字符串的第 <code>i</code> 个字节，那么 <code>&amp;s[i]</code> 是无效的。
</p>


<h3 id="Array_types">数组类型</h3>

<p>
	数组是单一类型元素的有序序列，该单一类型称为元素类型。
	元素的个数被称为数组长度，并且不能为负值。
</p>

<pre class="ebnf">
ArrayType   = "[" ArrayLength "]" ElementType .
ArrayLength = Expression .
ElementType = Type .
</pre>

<p>
	长度是数组类型的一部分；它必须为一个可以被 <code>int</code> 类型的值所<a href="#Representability">代表</a>的非负<a href="#Constants">常量</a>。
	数组的长度 <code>a</code> 可以使用内置函数 <a href="#Length_and_capacity"><code>len</code></a> 获取到。
	元素可以通过整数<a href="#Index_expressions">索引</a> 0 到 <code>len(a)-1</code> 来寻址到。
	数组类型总是一维的，但可以被组合以形成多维类型。
</p>

<pre>
[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // same as [2]([2]([2]float64))
</pre>

<h3 id="Slice_types">切片类型</h3>

<p>
	切片是针对一个<i>底层数组</i> 的连续段的描述符，它提供了对该数组内有序序列元素的访问。
	切片类型表示其元素类型的数组的所有切片的集合。
	元素的数量被称为切片长度，且不能为负。未初始化的切片的值为 <code>nil</code>。
</p>

<pre class="ebnf">
SliceType = "[" "]" ElementType .
</pre>

<p>
	切片 <code>s</code> 的长度可以使用内置函数 <a href="#Length_and_capacity"><code>len</code></a> 获取到；和数组不同的是，这个长度可能会在执行过程中改变。
	元素可以通过整数<a href="#Index_expressions">索引</a> 0  到 <code>len(s)-1</code> 寻址到。
	一个给定元素的切片索引可能小于其底层数组中相同元素的索引。
</p>
<p>
	切片一旦初始化便始终关联到存放其元素的底层数组。
	因此，一个切片与其数组以及相同数组的其他切片共享存储区；相反，不同的数组始终代表不同的存储。
</p>
<p>
	切片底层的数组可以延伸超过切片的末端。
	<i>容量</i> 便是对这个范围的测量：它是切片的长度与切片以外的数组的长度之和；可以通过从原始切片中<a href="#Slice_expressions"><i>切</i></a> 一个新切片来创建长度达到该容量的切片。
	切片 <code>a</code> 的容量可以使用内置函数 <a href="#Length_and_capacity"><code>cap(a)</code></a> 获取到。
</p>

<p>
	使用内置函数 <a href="#Making_slices_maps_and_channels"><code>make</code></a> 创建给定元素类型 <code>T</code> 的新的初始化切片值，该函数采用切片类型和参数来指定长度和容量（可选）。
	使用 <code>make</code> 创建的切片总是分配一个新的隐藏的数组，返回的切片值将引用该数组。
	也就是，执行
</p>

<pre>
make([]T, length, capacity)
</pre>

<p>
	就像分配个数组然后<a href="#Slice_expressions">再分片</a>它一样来产生相同的切片，所以如下两个表达式是等效的：
</p>

<pre>
make([]int, 50, 100)
new([100]int)[0:50]
</pre>

<p>
	如同数组一样，切片总是一维的但可以通过组合来构造高维的对象。
	数组间组合时，被构造的内部数组总是拥有相同的长度；但切片与切片（或数组与切片）组合时，内部的长度可能是动态变化的。
	此外，内部切片必须单独初始化。
</p>

<h3 id="Struct_types">结构体类型</h3>

<p>
	结构体是命名元素的一个序列，这些元素被称为字段，每一个都有一个名字和一个类型。
	字段名可以被显式指定（IdentifierList）也可以被隐式指定（EmbeddedField）。
	在结构体中，非<a href="#Blank_identifier">空白</a>字段名必须是<a href="#Uniqueness_of_identifiers">唯一的</a>。
</p>

<pre class="ebnf">
StructType    = "struct" "{" { FieldDecl ";" } "}" .
FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .
EmbeddedField = [ "*" ] TypeName .
Tag           = string_lit .
</pre>

<pre>
// 一个空的结构体。
struct {}

// 一个有六个字段的结构体。
struct {
	x, y int
	u float32
	_ float32  // padding
	A *[]int
	F func()
}
</pre>

<p>
	一个声明了类型但没有显式的字段名的字段就是<i>嵌入字段</i>。
	嵌入字段必须指定为一个类型名 <code>T</code> 或指向非接口类型名称 <code>*T</code> 的指针，并且 <code>T</code> 本身可能不是一个指针类型。
	这个非限定的类型名就被当作字段名。
</p>

<pre>
// 四个类型分别为 T1，*T2，P.T3，*P.T4 的嵌入字段所组成的结构体
struct {
	T1        // 字段名为 T1
	*T2       // 字段名为 T2
	P.T3      // 字段名为 T3
	*P.T4     // 字段名为 T4
	x, y int  // 字段名为 x 和 y
}
</pre>

<p>
	以下声明是非法的，因为在一个结构体类型中，字段名必须是唯一的：
</p>

<pre>
struct {
	T     // 与嵌入字段 *T 和 *P.T 冲突
	*T    // 与嵌入字段  T 和 *P.T 冲突
	*P.T  // 与嵌入字段  T 和   *T 冲突
}
</pre>

<p>
	在结构体 <code>x</code> 中，一个嵌入字段的字段或<a href="#Method_declarations">方法</a> <code>f</code> 被称作 <i>promoted</i> ，前提是 <code>x.f</code> 是一个表示那个字段或方法 <code>f</code> 的合法<a href="#Selectors">选择器</a>。
</p>

<p>
	除了不能在结构体的<a href="#Composite_literals">复合字面量</a>中作为字段名外，promoted 字段和结构体的普通字段一样。
</p>

<p>
	给定一个结构体类型 <code>S</code> 和一个 <a href="#Type_definitions">定义类型</a> <code>T</code>，promoted 方法包含在这个结构体的方法集中的情况分为：
</p>
<ul>
	<li>
		如果 <code>S</code> 包含一个嵌入字段 <code>T</code>，那么 <code>S</code> 和 <code>*S</code> 的<a href="#Method_sets">方法集</a>都包括了接收者为 <code>T</code> 的 promoted 方法。
		<code>*S</code> 的方法集还包括了接收者为 <code>*T</code> 的 promoted 方法。
	</li>

	<li>
		如果 <code>S</code> 包含了一个嵌入字段 <code>*T</code> ，那么 <code>S</code> 和 <code>*S</code> 的方法集都包括了接收者为 <code>T</code> 或 <code>*T</code> 的 promoted 方法。
	</li>
</ul>

<p>
	字段声明可以紧跟着一个可选的字符串字面量<i>标签</i>，在对应的字段声明中，它将成为针对所有这个字段的属性。
	空的标签字符串等于没有标签。
	标签可以通过<a href="/pkg/reflect/#StructTag">反射接口</a>被可视化，并且可以参与到结构体的<a href="#Type_identity">类型一致性</a>中，但其它情况下都是被忽略的。
</p>

<pre>
struct {
	x, y float64 ""  // 空的标签字面值和没有标签一样
	name string  "any string is permitted as a tag"
	_    [4]byte "ceci n'est pas un champ de structure"
}

// 对应时间戳协议缓冲区的结构体。
// 其标签字符串定义了协议缓冲区的字段号；
// 它们遵循了由 reflect 包所概述的转换规则。
struct {
	microsec  uint64 `protobuf:"1"`
	serverIP6 uint64 `protobuf:"2"`
}
</pre>

<h3 id="Pointer_types">指针类型</h3>

<p>
	指针类型表示指向一给定类型的<a href="#Variables">变量</a>的所有指针的集合，这个给定类型称为该指针的<i>基础类型</i>。
	未初始化的指针的值为 <code>nil</code>。
</p>

<pre class="ebnf">
PointerType = "*" BaseType .
BaseType    = Type .
</pre>

<pre>
*Point
*[4]int
</pre>

<h3 id="Function_types">函数类型（Function types）</h3>

<p>
	函数类型表示具有相同参数和结果类型的所有函数的集合。
	函数类型的未初始化的变量的值为 <code>nil</code>。
</p>

<pre class="ebnf">
FunctionType   = "func" Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = "(" [ ParameterList [ "," ] ] ")" .
ParameterList  = ParameterDecl { "," ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
</pre>

<p>
	在参数或结果的列表中，名字（IdentifierList）要么全部存在，要么全部不存在。
	如果存在，则每个名字代表特定类型的一项（参数或者结果），签名中的所有非<a href="#Blank_identifier">空白</a>名称必须是<a href="#Uniqueness_of_identifiers">唯一的</a>。
	如果不存在，则每种类型都代表该类型的一项。
	参数和结果列表始终带有括号，但如果有一个未命名的结果，则可以将其写为非括号的形式。
</p>

<p>
	函数签名中最后的进入参数可以是以 <code>...</code> 为前缀的类型。
	带这样一个参数的函数被称为 <i>可变（variadic）</i>，它可以携带针对该形参的零或多个实参来调用。
</p>

<pre>
func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)
</pre>


<h3 id="Interface_types">接口类型</h3>

<p>
	接口类型指定了一个称为<i>接口</i> 的<a href="#Method_sets">方法集</a>。
	一个接口变量可以存储任意类型的值，这个类型要带有一个方法集，方法集需要是该接口的任意超集。
	这样子的类型就被叫做<i>实现了这个接口</i>。
	接口类型的未初始化的变量的值为 <code>nil</code>。
</p>

<pre class="ebnf">
InterfaceType      = "interface" "{" { ( MethodSpec | InterfaceTypeName ) ";" } "}" .
MethodSpec         = MethodName Signature .
MethodName         = identifier .
InterfaceTypeName  = TypeName .
</pre>

<p>
	接口类型可以通过方法规范<i>显式地</i> 指定其方法，也可以通过接口类型名<i>嵌入</i> 其它接口的方法。
</p>

<pre>
// 一个简单的 File 接口。
interface {
	Read([]byte) (int, error)
	Write([]byte) (int, error)
	Close() error
}
</pre>

<p>
	显式指定的方法必须是<a href="#Uniqueness_of_identifiers">唯一的</a>且非<a href="#Blank_identifier">空白</a>的。
</p>

<pre>
interface {
	String() string
	String() string  // 非法: String 不是唯一的
	_(x int)         // 非法: 方法不能是空白名
}
</pre>

<p>
	多个类型可以实现一个相同的接口。
	比如，如果两个类型 <code>S1</code> 和 <code>S2</code> 有方法集
</p>

<pre>
func (p T) Read(p []byte) (n int, err error)
func (p T) Write(p []byte) (n int, err error)
func (p T) Close() error
</pre>

<p>
	（其中 <code>T</code> 代表 <code>S1</code> 或 <code>S2</code>）那么 <code>File</code> 接口就被 <code>S1</code> 和 <code>S2</code> 实现了，不管 <code>S1</code> 和 <code>S2</code> 是否有其它的（或共享的）方法。
</p>

<p>
	一个类型实现了包括其方法的子集的任意接口，因此可能实现了好几个截然不同的接口。
	比如，所有的类型都实现了<i>空</i> 接口：
</p>

<pre>
interface{}
</pre>

<p>
	同样，请考虑以下接口规范，该规范出现在<a href="#Type_declarations">类型声明</a> 中，通过该规范定义被称为 <code>Locker</code> 的接口：
</p>

<pre>
type Locker interface {
	Lock()
	Unlock()
}
</pre>

<p>
	如果 <code>S1</code> 和 <code>S2</code> 也实现了
</p>

<pre>
func (p T) Lock() { … }
func (p T) Unlock() { … }
</pre>

<p>
	和 <code>File</code> 接口一样，它们也实现了 <code>Locker</code> 接口。
</p>

<p>
	一个接口 <code>T</code> 可以使用（可能是限定的）接口类型名 <code>E</code> 代替方法规范。
	这叫做在 <code>T</code> 中的<i>内嵌</i> 接口 <code>E</code>；<code>T</code> 的<a href="#Method_sets">方法集</a> 是 <code>T</code> 的显式声明的方法和 <code>T</code> 的嵌入接口的方法的集合的<i>联合</i>。
</p>

<pre>
type Reader interface {
	Read(p []byte) (n int, err error)
	Close() error
}

type Writer interface {
	Write(p []byte) (n int, err error)
	Close() error
}

// ReadWriter 的方法是 Read, Write, Close
type ReadWriter interface {
	Reader  // 在 ReadWriter 的方法集中包含 Reader 的方法
	Writer  // 在 ReadWriter 的方法集中包含 Writer 的方法
}
</pre>

<p>
	方法集合的<i>联合</i> 仅包含每一个方法集中（暴露的和非暴露的）方法一次，且<a href="#Uniqueness_of_identifiers">同名</a> 方法必须拥有<a href="#Type_identity">一致的</a> 签名。
</p>

<pre>
type ReadCloser interface {
	Reader   //  在 ReadCloser 的方法集中包含 Reader 的方法
	Close()  // 非法： Reader.Close 的签名和 Close 的不同
}
</pre>

<p>
	接口类型 <code>T</code> 可能不会递归地嵌入自己或嵌入 <code>T</code> 的任何接口类型。
</p>

<pre>
// 非法: Bad 不能嵌入它自己
type Bad interface {
	Bad
}

// 非法: Bad1 不能通过 Bad2 来嵌入它自己
type Bad1 interface {
	Bad2
}
type Bad2 interface {
	Bad1
}
</pre>

<h3 id="Map_types">Map类型</h3>

<p>
	map 是单一类型元素所组成的无序组，这个单一类型被称为元素类型。元素由另一个类型的 <i>键</i> 的集合来索引，这个另一个类型被称为键类型。
	一个未初始化的 map 的值为 <code>nil</code>。
</p>

<pre class="ebnf">
MapType     = "map" "[" KeyType "]" ElementType .
KeyType     = Type .
</pre>

<p>
	<a href="#Comparison_operators">比较运算符</a> <code>==</code> 和 <code>!=</code> 对键类型操作而言必须是要完全定义的；因此键类型不能为一个函数、map 或切片。
	如果键类型是一个接口类型，那么比较运算符必须针对其动态键值做完全定义；失败会导致一个 <a href="#Run_time_panics">run-time panic</a>。

</p>

<pre>
map[string]int
map[*T]struct{ x, y float64 }
map[string]interface{}
</pre>

<p>
	map 元素的数目被称为其长度。
	对于一个 map <code>m</code>，长度可以使用内置函数 <a href="#Length_and_capacity"><code>len</code></a> 获取并且它可能会在执行过程中改变。
	元素可以在执行过程中使用<a href="#Assignments">赋值</a>来进行添加，可以使用<a href="#Index_expressions">索引表达式</a>来获取；可以使用内置函数 <a href="#Deletion_of_map_elements"><code>delete</code></a> 来移除。
</p>
<p>
	一个新的、空的 map 值的创建使用的是内置函数 <a href="#Making_slices_maps_and_channels"><code>make</code></a>，其获取 map 类型和一个可选的容量提示作为实参：
</p>

<pre>
make(map[string]int)
make(map[string]int, 100)
</pre>

<p>
	初始化的容量不会限制其大小：maps 会增长以适合其存储项目的数量，除了 <code>nil</code> maps。
	<code>nil</code> map 相当于空 map，但是 nil map 不能添加元素。
</p>

<h3 id="Channel_types">Channel类型</h3>

<p>
	channel 为<a href="#Go_statements">并发执行函数</a>提供了一个<a href="#Send_statements">发送</a>和<a href="#Receive_operator">接收</a>特定类型值的机制。
	未初始化的 channel 的值为 <code>nil</code> 。
</p>

<pre class="ebnf">
ChannelType = ( "chan" | "chan" "&lt;-" | "&lt;-" "chan" ) ElementType .
</pre>

<p>
	可选的 <code>&lt;-</code> 操作符指定了信道的<i>方向</i>，<i>发送</i> 或<i>接收</i>。
	如果没有指定方向，这个 channel 就是<i>双向的</i>。
	通过<a href="#Assignments">赋值</a>或显式的<a href="#Conversions">转换</a>，channel 可以被限制为仅能发送或仅能接收。
</p>

<pre>
chan T          // 可用于发送或接收类型为 T 的值
chan&lt;- float64  // 仅用于发送 float64 类型
&lt;-chan int      // 仅用于接收 int 类型
</pre>

<p>
	<code>&lt;-</code> 操作符与最左的 <code>chan</code> 关联的一些可能性：
</p>

<pre>
chan&lt;- chan int    // same as chan&lt;- (chan int)
chan&lt;- &lt;-chan int  // same as chan&lt;- (&lt;-chan int)
&lt;-chan &lt;-chan int  // same as &lt;-chan (&lt;-chan int)
chan (&lt;-chan int)
</pre>

<p>
	一个新的，初始化的 channel 值的创建可以使用内置的函数 <a href="#Making_slices_maps_and_channels"><code>make</code></a>，它获取 channel 类型和可选的<i>容量</i> 作为实参：
</p>

<pre>
make(chan int, 100)
</pre>

<p>
	容量，即元素的数量，它确定了 channel 中缓冲区的大小。
	如果容量为零或没有写，那么 channel 就是无缓冲的，这种情况下，只有在接收端和发送端都准备好的情况下，通信才会成功。
	不然 channel 就是有缓冲的，这种情况下只要不阻塞，通信便会成功；阻塞是指缓冲区满了（对于发送端而言）或者缓冲区空了（对于接收端而言）。
	一个 <code>nil</code> 的 channel 是不能用于通信的。
</p>

<p>
	channel 可以使用内置函数 <a href="#Close"><code>close</code></a> 来关闭。
	<a href="#Receive_operator">接收运算符</a>的多值分配形式报告了在 channel 关闭前接收到的值是否已经被发送了。
</p>

<p>
	单个 channel 可用于<a href="#Send_statements">发送语句</a>，<a href="#Receive_operator">接受操作</a>以及由任意数量的 goroutine 对内置函数 <a href="#Length_and_capacity"><code>cap</code></a> 和 <a href="#Length_and_capacity"><code>len</code></a> 的调用，而无需进一步同步。
	Channels 是一个先进先出的队列。
	举例，如果一个 goroutine 在信道上发送了值，第二个 goroutine 接收了这些值，那么这些值是按照发送的顺序被接收的。
</p>

<h2 id="Properties_of_types_and_values">类型和值的属性</h2>

<h3 id="Type_identity">类型一致性</h3>

<p>
	两个类型，要么是<i>一致的</i> 要么是<i>不同的</i>。
</p>

<p>
	<a href="#Type_definitions">定义类型</a>和其它类型总是不同的。
	不然的话，如果两个类型所对应的<a href="#Type_definitions">潜在类型</a>字面量是结构一致的；也就是说它们拥有相同的字面量结构并且对应的组成部分拥有一致的类型，那么它们便是一致的。
	详细来说：
</p>

<ul>
	<li>如果两个数组类型有一致的元素类型和相同的数组长度，那么它们便是一致的。</li>

	<li>如果两个切片类型有一致的元素类型，那么它们便是一致的。</li>

	<li>
		如果两个结构体有相同的字段序列，并且对应的字段有相同的名字、一致的类型和一致的标签，那么它们便是一致的。
		不同包的<a href="#Exported_identifiers">非暴露的</a>字段名总是不同的。</li>

	<li>如果两个指针类型有一致的基础类型，那么它们便是一致的。</li>

	<li>如果两个函数类型有相同的参数数量和结果值，并且对应的参数和结果类型是一致的，并且两者要么都是 variadic 要么都不是，那么它们便是一致的。
		参数和结果名不是必须匹配的。</li>

	<li>如果两个接口类型有一样的带相同名字和一致的函数类型的方法集，那么它们便是一致的。
		不同包的<a href="#Exported_identifiers">非暴露的</a>方法名总是不同的。方法的顺序是无关紧要的。</li>

	<li>如果两个 map 类型有一致的键类型和值类型，那么它们便是一致的。</li>

	<li>如果两个 channel 类型有一致的值类型和相同的方向，那么它们便是一致的。</li>
</ul>

<p>
	给出声明
</p>

<pre>
type (
	A0 = []string
	A1 = A0
	A2 = struct{ a, b int }
	A3 = int
	A4 = func(A3, float64) *A0
	A5 = func(x int, _ float64) *[]string
)

type (
	B0 A0
	B1 []string
	B2 struct{ a, b int }
	B3 struct{ a, c int }
	B4 func(int, float64) *B0
	B5 func(x int, y float64) *A1
)

type	C0 = B0
</pre>

<p>
	这些类型是一致的：
</p>

<pre>
A0, A1, and []string
A2 and struct{ a, b int }
A3 and int
A4, func(int, float64) *[]string, and A5

B0 and C0
[]int and []int
struct{ a, b *T5 } and struct{ a, b *T5 }
func(x int, y float64) *[]string, func(int, float64) (result *[]string), and A5
</pre>

<p>
	<code>B0</code> 和 <code>B1</code> 是不同的，因为它们是被不同的<a href="#Type_definitions">类型定义</a>所创建的新类型；<code>func(int, float64) *B0</code> 和 <code>func(x int, y float64) *[]string</code> 是不同的，因为 <code>B0</code> 和 <code>[]string</code> 是不同的。
</p>


<h3 id="Assignability">可分配性</h3>

<p>
	在如下这些情况中，值 <code>x</code> <i>可以分配</i> 给一个类型为 <code>T</code> 的<a href="#Variables">变量</a>（“ <code>x</code> 可以分配给 <code>T</code> ”）：
</p>

<ul>
<li>
	<code>x</code> 的类型和 <code>T</code> 一致。
</li>
<li>
	<code>x</code> 的类型 <code>V</code> 和 <code>T</code> 有一致的<a href="#Types">潜在类型</a>并且二者最少有一个不是<a href="#Type_definitions">定义类型</a>。
</li>
<li>
<code>T</code> 是一个接口类型，而 <code>x</code> <a href="#Interface_types">实现了</a> <code>T</code>.
</li>
<li>
<code>x</code> 是一个双向的 channel 值，<code>T</code> 是一个 channel 类型,<code>x</code> 的类型 <code>V</code> 和 <code>T</code> 有一致的元素值，并且 <code>V</code> 和 <code>T</code> 中至少有一个不是定义类型。
</li>
<li>
<code>x</code> 是一个预先声明的标识符 <code>nil</code> 而 <code>T</code> 是一个指针、函数、切片、map、channel 或接口类型。
</li>
<li>
	<code>x</code> 是一个无类型的可以被类型 <code>T</code> 的一个值所<a href="#Representability">代表</a>的<a href="#Constants">常量</a>。
</li>
</ul>


<h3 id="Representability">可表示性</h3>

<p>
	只要以下条件有一个成立，那么<a href="#Constants">常量</a> <code>x</code> 就可以被一个类型为 <code>T</code> 的值所<i>表示</i>：
</p>

<ul>
<li>
	<code>x</code> 在 <code>T</code> <a href="#Types">确定的</a>一组值中。
</li>

<li>
	<code>T</code> 是一个浮点类型并且 <code>x</code> 可以被不溢出地约到 <code>T</code> 的精度。
	约数用的是 IEEE 754 round-to-even 规则，但是 IEEE 负零会被进一步简化到一个无符号的零。
	注：这种常量值不会出现 IEEE 负零、 NaN 或者无穷。
</li>

<li>
	<code>T</code> 是一个复合类型并且 <code>x</code> 的<a href="#Complex_numbers">组成</a> <code>real(x)</code> 和 <code>imag(x)</code> 是可以被 <code>T</code> 的组成类型（<code>float32</code> 或者 <code>float64</code>）所表示的。
</li>
</ul>

<pre>
x                   T           x 可以被 T 表示的原因是

'a'                 byte        97 在 byte 值集中
97                  rune        rune 是 int32 的别名且 97 在 32 位整数值集中
"foo"               string      "foo" 在 string 值集中
1024                int16       1024 在 16 位整数值集中
42.0                byte        42 在无符号 8 位整数值集中
1e10                uint64      10000000000 在无符号 64 位整数值集中
2.718281828459045   float32     2.718281828459045 约到 2.7182817 后在 float32 值集中
-1e-1000            float64     -1e-1000 约到 IEEE -0.0 后再被进一步简化到 0.0
0i                  int         0 是一个整数值
(42 + 0i)           float32     42.0 （带虚部零）在 float32 值集中
</pre>

<pre>
x                   T           x 不能被 T 表示的原因是

0                   bool        0 不在 boolean 值集中
'a'                 string      'a' 是 rune，它不在 string 值集中
1024                byte        1024 不在无符号 8 位整数值集中
-1                  uint16      -1 不在无符号 16 位整数值集中
1.1                 int         1.1 不是一个整数值
42i                 float32     （0 + 42i） 不在 float32 值集中
1e1000              float64     1e1000 约数后溢出了 IEEE +Inf
</pre>


<h2 id="Blocks">块（Blocks）</h2>

<p>
	<i>块</i> 是在一对花括号内声明和语句的序列，这个序列可能是空的。
</p>

<pre class="ebnf">
Block = "{" StatementList "}" .
StatementList = { Statement ";" } .
</pre>

<p>
	源代码中除了显式的块外，还有隐式的块：
</p>

<ol>
	<li>包围所有 Go 原始文本的 <i>universe 块</i>。</li>

	<li>每个<a href="#Packages">包</a>有一个包含针对该包的所有 Go 原始文本的<i>包块</i>。</li>

	<li>每个文件有一个包含在该文件中所有 Go 原始文本的<i>文件块</i>。</li>

	<li>每个 <a href="#If_statements">"if"</a>，<a href="#For_statements">"for"</a> 和 <a href="#Switch_statements">"switch"</a> 语句都被认为是在其自己的隐式块中。</li>

	<li>每个在 <a href="#Switch_statements">"switch"</a> 或 <a href="#Select_statements">"select"</a> 语句中的子句都作为一个隐式的块。</li>
</ol>

<p>
	块是嵌套的并影响着<a href="#Declarations_and_scope">作用域</a>。
</p>


<h2 id="Declarations_and_scope">声明和作用域</h2>

<p>
	<i>声明</i> 绑定了非<a href="#Blank_identifier">空白</a>的标识符到<a href="#Constant_declarations">常量</a>、<a href="#Type_declarations">类型</a>、<a href="#Variable_declarations">变量</a>、<a href="#Function_declarations">函数</a>、<a href="#Labeled_statements">标签</a>或<a href="#Import_declarations">包</a>。
	程序中的每个标识符都必须要声明。
	同一个块中不能定义一个标识符两次，并且没有标识符可以同时在文件块和包块中定义。
</p>

<p>
	<a href="#Blank_identifier">空白标识符</a>可以像声明中的任何其他标识符一样使用，但是它不会引入绑定，因此不会被声明。
	在包块中，标识符 <code>init</code> 只能用于 <a href="#Package_initialization"><code>init</code> 函数</a>声明，且和空白标识符一样，它不会引出一个新的绑定。
</p>

<pre class="ebnf">
Declaration   = ConstDecl | TypeDecl | VarDecl .
TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
</pre>

<p>
	声明的标识符的<i>作用域</i> 是该标识符表示特定常量、类型、变量、函数、标签或包时所处的原始文本的范围。
</p>

<p>
	Go 使用<a href="#Blocks">块</a>来定作用域：
</p>

<ol>
	<li><a href="#Predeclared_identifiers">预先声明的标识符</a>的作用域为 universe 块。</li>

	<li>表示在顶层（任何函数之外）声明的常量，类型，变量或函数（但不是方法）的标识符的作用域是包块。</li>

	<li>导入包的包名的作用域是包含导入声明在内的的文件的文件块。</li>

	<li>表示方法接收者，函数参数或结果变量的标识符的作用域为函数主体。</li>

	<li>在函数内定义的常量或变量标识符的作用域起始于 ConstSpec 或 VarSpec（对短变量来说为 ShortVarDecl）的尾端，结束于包含着它的最内的块。</li>

	<li>在函数内定义的类型标识符的作用域起始于 TypeSpec 的标识符，结束于包含着它的最内的块。</li>
</ol>

<p>
	在块中声明的标识符可以在其内的块中重新声明。
	当内部声明的标识符在作用域内，它表示内部声明所声明的实体。
</p>

<p>
	<a href="#Package_clause">包子句</a>不是一个声明；包名不会在任何作用域中出现。
	它的目的是确定一个文件属于相同的<a href="#Packages">包</a>和针对导入声明指定默认的包名。
</p>


<h3 id="Label_scopes">标签作用域</h3>

<p>
	标签是由<a href="#Labeled_statements">标签语句</a>所声明的，它用在 <a href="#Break_statements">"break"</a>、<a href="#Continue_statements">"continue"</a> 和 <a href="#Goto_statements">"goto"</a> 语句中。
	定义一个不去用的标签是非法的。
	与其它标识符相对比，标签不按块分作用域，
	也不和那些不是标签的标识符冲突。
	标记的作用域是声明时所在的函数的主体，不过要排除所有嵌套函数的主体。
</p>


<h3 id="Blank_identifier">空白标识符</h3>

<p>
	<i>空白标识符</i> 由下划线字符 <code>_</code> 所代表。
	它充当一个匿名的占位符替代常规的（非空白的）标识符，并且作为<a href="#Operands">操作数</a>在<a href="#Declarations_and_scope">声明</a>和<a href="#Assignments">赋值</a>中有特殊的意义。
</p>


<h3 id="Predeclared_identifiers">预声明的标识符</h3>

<p>
	以下的标识符是在 <a href="#Blocks">universe 块</a>中被隐式地定义的：
</p>
<pre class="grammar">
Types:
	bool byte complex64 complex128 error float32 float64
	int int8 int16 int32 int64 rune string
	uint uint8 uint16 uint32 uint64 uintptr

Constants:
	true false iota

Zero value:
	nil

Functions:
	append cap close complex copy delete imag len
	make new panic print println real recover
</pre>


<h3 id="Exported_identifiers">暴露的标识符</h3>

<p>
	标识符可以被<i>暴露</i> 用来允许从另一个包访问到它。
	一个标识符将会被暴露如果同时满足：
</p>
<ol>
	<li>标识符的首字母为 Unicode 大写字母（Unicode 类 "Lu"）；</li>
	<li>标识符是在<a href="#Blocks">包块</a>中声明的或者它是一个<a href="#Struct_types">字段名</a>或<a href="#MethodName">方法名</a>。</li>
</ol>
<p>
	所有其它的标识符是不暴露的。
</p>


<h3 id="Uniqueness_of_identifiers">标识符的唯一性</h3>

<p>
	给定一组标识符，如果标识符在集合中彼此<i>不同</i>，则称为<i>唯一</i> 标识符。
	如果两个标识符拼写不同，或它们处于不同的<a href="#Packages">包</a>并且没有被<a href="#Exported_identifiers">暴露</a>，那么它们便是不同的。
	否则，它们便是相同的。
</p>

<h3 id="Constant_declarations">常量声明</h3>

<p>
	常量声明绑定了一个标识符的列表（常量的名字）到<a href="#Constant_expressions">常量表达式</a>列表的值。
	标识符的数量必须等于表达式的数量，并且左侧第 <i>n</i> 个标识符绑定到了右侧第 <i>n</i> 个表达式的值。
</p>

<pre class="ebnf">
ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .

IdentifierList = identifier { "," identifier } .
ExpressionList = Expression { "," Expression } .
</pre>

<p>
	如果存在该类型，则所有常量都需采用该指定的类型，并且表达式必须<a href="#Assignability">可分配</a>给该类型。
	如果省略该类型，则常量采用相应表达式的各个类型。
	如果表达式的值为无类型<a href="#Constants">常量</a>，那么声明的常量保持为无类型，常量标识符表示着该常量的值。
	比如，如果一个表达式为浮点数字面量，那么即使字面量的小数部分为零，常量标识符依旧表示一个浮点数常量。
</p>

<pre>
const Pi float64 = 3.14159265358979323846
const zero = 0.0         // 无类型的浮点数常量
const (
	size int64 = 1024
	eof        = -1  // 无类型的整数常量
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo", 无类型的整数和字符串常量
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
</pre>

<p>
	在带括号的 <code>const</code> 声明列表中，除第一个 ConstSpec 外，其他任何表达式都可以省略。
	这样的一个空列表相当于第一个前面的非空表达式列表及其类型（如果有的话）的文本替换。
	省略表达式的列表就因此相当于重复之前的列表。
	标识符的数量必须等于之前列表的表达式的数量。
	这个机制结合 <a href="#Iota"><code>iota</code> 常量生成器</a>允许了连续值的轻量声明：
</p>

<pre>
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Partyday
	numberOfDays  // 这个常量是不暴露的
)
</pre>


<h3 id="Iota">Iota</h3>

<p>
	在一个<a href="#Constant_declarations">常量声明</a>中，预先声明的标识符 <code>iota</code> 代表连续的无类型的整数<a href="#Constants">常量</a>。
	它的值从零开始，是在常量声明中各自的 <a href="#ConstSpec">ConstSpec</a> 的索引。
	其可以用于构造一组相关常量的集合：
</p>

<pre>
const (
	c0 = iota  // c0 == 0
	c1 = iota  // c1 == 1
	c2 = iota  // c2 == 2
)

const (
	a = 1 &lt;&lt; iota  // a == 1  (iota == 0)
	b = 1 &lt;&lt; iota  // b == 2  (iota == 1)
	c = 3          // c == 3  (iota == 2, unused)
	d = 1 &lt;&lt; iota  // d == 8  (iota == 3)
)

const (
	u         = iota * 42  // u == 0     (无类型的整数常量)
	v float64 = iota * 42  // v == 42.0  (float64 常量)
	w         = iota * 42  // w == 84    (无类型的整数常量)
)

const x = iota  // x == 0
const y = iota  // y == 0
</pre>

<p>
	定义上，在同一个 ConstSpec 中使用的多个 <code>iota</code> 都拥有相同的值：
</p>

<pre>
const (
	bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1  // bit0 == 1, mask0 == 0  (iota == 0)
	bit1, mask1                           // bit1 == 2, mask1 == 1  (iota == 1)
	_, _                                  //                        (iota == 2, unused)
	bit3, mask3                           // bit3 == 8, mask3 == 7  (iota == 3)
)
</pre>

<p>
	最后一个例子利用了上一个非空表达式列表的<a href="#Constant_declarations">隐式重复</a>。
</p>


<h3 id="Type_declarations">类型声明</h3>

<p>
	一个类型声明绑定了一个标识符（也就是<i>类型名</i>）到一个<a href="#Types">类型</a>。
	类型声明有两种形式：别名声明和类型定义。
</p>

<pre class="ebnf">
TypeDecl = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
TypeSpec = AliasDecl | TypeDef .
</pre>

<h4 id="Alias_declarations">别名声明</h4>

<p>
	别名声明绑定了一个标识符到一个给定的类型。
</p>

<pre class="ebnf">
AliasDecl = identifier "=" Type .
</pre>

<p>
	在标识符的<a href="#Declarations_and_scope">作用域</a>内，它充当了该类型的<i>别名</i>。
</p>

<pre>
type (
	nodeList = []*Node  // nodeList 和 []*Node 的类型一致
	Polar    = polar    // Polar 和 polar 表示的类型一致
)
</pre>


<h4 id="Type_definitions">类型定义</h4>

<p>
	类型定义创建一个新的、不同的类型，其具有与给定类型相同的<a href="#Types">潜在类型</a>和操作，并将标识符绑定到它。
</p>

<pre class="ebnf">
TypeDef = identifier Type .
</pre>

<p>
	新类型被称为<i>定义类型</i>。
	它和其它任何的类型（包括那个给定类型）都是<a href="#Type_identity">不同的</a>。
</p>

<pre>
type (
	Point struct{ x, y float64 }  // Point 和 struct{x, y float64} 是不同的类型
	polar Point                   // polar 和 Point 表示不同的类型
)

type TreeNode struct {
	left, right *TreeNode
	value *Comparable
}

type Block interface {
	BlockSize() int
	Encrypt(src, dst []byte)
	Decrypt(src, dst []byte)
}
</pre>

<p>
	定义类型可能具有与之关联的<a href="#Method_declarations">方法</a>。
	它不会继承任何绑定到给定类型的方法，但接口类型或者复合类型元素的<a href="#Method_sets">方法集</a>是保持不变的：
</p>

<pre>
// Mutex 是带两个方法 Lock 和 Unlock 的数据类型。
type Mutex struct         { /* Mutex 字段 */ }
func (m *Mutex) Lock()    { /* Lock 实现  */ }
func (m *Mutex) Unlock()  { /* Unlock 实现  */ }

// NewMutex 和 Mutex 有相同的构成，但是其方法集是空的。
type NewMutex Mutex

// PtrMutex 的潜在类型 *Mutex 的方法集是保持不变的，
// 但 PtrMutex 的方法集是空的。
type PtrMutex *Mutex

// *PrintableMutex 的方法集包含了绑定到它的嵌入字段 Mutex 的方法 Lock 和 Unlock 。
type PrintableMutex struct {
	Mutex
}

// MyBlock 是一个和 Block 有着相同方法集的接口类型。
type MyBlock Block
</pre>

<p>
	类型声明可以用于定义不同的布尔、数值或字符串类型，并关联方法给它：
</p>

<pre>
type TimeZone int

const (
	EST TimeZone = -(5 + iota)
	CST
	MST
	PST
)

func (tz TimeZone) String() string {
	return fmt.Sprintf("GMT%+dh", tz)
}
</pre>


<h3 id="Variable_declarations">变量声明</h3>

<p>
	变量声明会创建一个或多个<a href="#Variables">变量</a>，给它们绑定对应的标识符，并为每个标识符提供一个类型和一个初始值。
</p>

<pre class="ebnf">
VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
</pre>

<pre>
var i int
var U, V, W float64
var k = 0
var x, y float32 = -1, -2
var (
	i       int
	u, v, s = 2.0, 3.0, "bar"
)
var re, im = complexSqrt(-1)
var _, found = entries[name]  // map 查找；只关心 "found"
</pre>

<p>
	如果给出了表达式列表，那么变量会根据<a href="#Assignments">赋值</a>规则由表达式来初始化。否则，每个变量都被初始化为其<a href="#The_zero_value">零值</a>。
</p>

<p>
	如果类型明确了，那么每个变量都会指定为那个类型。
	否则，每个变量的类型会被给定为赋值中对应的初始化值的类型。
	如果那个值是无类型的常量，它会先隐式地<a href="#Conversions">转换</a>为它的<a href="#Constants">默认类型</a>；如果它是一个无类型的布尔值，那么它会先隐式地转换为类型 <code>bool</code>。
	预先声明的值 <code>nil</code> 不能用于初始化没有明确类型的变量。
</p>

<pre>
var d = math.Sin(0.5)  // d 是 float64
var i = 42             // i 是 int
var t, ok = x.(T)      // t 是 T, ok 是 bool
var n = nil            // 非法
</pre>

<p>
	实现限制：当在<a href="#Function_declarations">函数实体</a>中定义的变量没有被使用时，编译器可以认定它为非法的。
</p>

<h3 id="Short_variable_declarations">短变量声明</h3>

<p>
	<i>短变量声明</i> 使用如下语法：
</p>

<pre class="ebnf">
ShortVarDecl = IdentifierList ":=" ExpressionList .
</pre>

<p>
	它是带有初始化表达式但没有类型的常规<a href="#Variable_declarations">变量声明</a>的简写：
</p>

<pre class="grammar">
"var" IdentifierList = ExpressionList .
</pre>

<pre>
i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w, _ := os.Pipe()  // os.Pipe() 返回一个连接着的文件对和一个 error （如果有的话）
_, y, _ := coord(p)   // coord() 返回三个值； 只关心 y 座标
</pre>

<p>
	与常规变量声明不同，短变量声明可以<i>重复声明</i> 变量，这个变量是在同一个块（或者参数列表——如果该块是一个函数实体的话）内之前已经声明过的，且变量类型不能改变，但是重复声明语句最少要存在一个新的非<a href="#Blank_identifier">空白</a>变量。
	因此，重复声明仅能出现在多变量简短声明中。重复声明不会引进新的变量；它仅赋一个新的值到原变量。
</p>

<pre>
field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // 重复声明了 offset
a, a := 1, 2                              // 非法: a 声明了两次，或者如果 a 已经在其它地方声明的了话那么就没有新的变量了
</pre>

<p>
	短变量声明只能出现在函数内。
	在一些针对诸如 <a href="#If_statements">"if"</a>、<a href="#For_statements">"for"</a> 或 <a href="#Switch_statements">"switch"</a> 这样的初始化器的上下文中，也可以用于声明本地临时变量。
</p>

<h3 id="Function_declarations">函数声明</h3>

<p>
	函数声明绑定一个标识符（也就是<i>函数名</i>）到一个函数。
</p>

<pre class="ebnf">
FunctionDecl = "func" FunctionName Signature [ FunctionBody ] .
FunctionName = identifier .
FunctionBody = Block .
</pre>

<p>
	如果函数的<a href="#Function_types">签名</a>声明了结果参数，那么函数体语句列表必须以<a href="#Terminating_statements">终止语句</a>结尾。
</p>

<pre>
func IndexRune(s string, r rune) int {
	for i, c := range s {
		if c == r {
			return i
		}
	}
	// 无效: 缺少返回语句
}
</pre>

<p>
	一个函数声明可以缺少函数体。
	这样的声明为 Go 语言外部实现的函数提供了签名，比如一个汇编程序。
</p>

<pre>
func min(x int, y int) int {
	if x &lt; y {
		return x
	}
	return y
}

func flushICache(begin, end uintptr)  // 由外部实现
</pre>

<h3 id="Method_declarations">方法声明</h3>

<p>
	方法是带<i>接收者</i> 的<a href="#Function_declarations">函数</a>。
	一个方法声明绑定了一个标识符（也就是<i>方法名</i> ）为一个方法，并与接收者的<i>基础类型</i> 关联。
</p>

<pre class="ebnf">
MethodDecl = "func" Receiver MethodName Signature [ FunctionBody ] .
Receiver   = Parameters .
</pre>

<p>
	接收者是使用在方法名之前的额外的参数段来指定的。
	这个参数段必须声明一个单一非 variadic 参数作为接收者。
	其类型必须为<a href="#Type_definitions">定义类型</a> <code>T</code> 或到定义类型 <code>T</code> 的指针。
	<code>T</code> 被称为接收者的<i>基础类型</i>。
	接收者的基本类型不能是一个指针或者接口类型，并且它必须在和方法相同的包中被声明。
	这个方法就被称为<i>绑定了</i> 这个基础类型，方法名只能通过类型 <code>T</code> 或 <code>*T</code> 的<a href="#Selectors">选择器</a>才可见。
</p>

<p>
	一个非<a href="#Blank_identifier">空白</a>接收者标识符在方法签名中必须是<a href="#Uniqueness_of_identifiers">唯一的</a>。
	如果接收者的值在方法实体内没有被引用，那么其标识符在声明时是可以省略的。
	一般来说这也同样适用于函数和方法的参数。
</p>

<p>
	对一个基础类型来说，绑定到它的非空白的方法名必须是唯一的。
	如果基础类型为<a href="#Struct_types">结构体类型</a>。
	那么非空白的方法和字段名必须是不同的。
</p>

<p>
	给定一个定义类型 <code>Point</code>，其声明如下：
</p>

<pre>
func (p *Point) Length() float64 {
	return math.Sqrt(p.x * p.x + p.y * p.y)
}

func (p *Point) Scale(factor float64) {
	p.x *= factor
	p.y *= factor
}
</pre>

<p>
	绑定了方法 <code>Length</code> 和 <code>Scale</code>，接收者类型为 <code>*Point</code>，对应基础类型 <code>Point</code>。
</p>

<p>
	方法的类型是该函数结合接收者作为的第一个参数的类型。
	比如，方法 <code>Scale</code> 有类型
</p>

<pre>
func(p *Point, factor float64)
</pre>

<p>
	不过，这样声明的函数并不是一个方法。
</p>


<h2 id="Expressions">表达式</h2>

<p>
	表达式通过将运算符和函数应用于操作数来规定值的计算。
</p>

<h3 id="Operands">操作数</h3>

<p>
	操作数表示表达式中基本的值。
	一个操作数可能是一个字面量；可能是一个（可能为<a href="#Qualified_identifiers">限定的</a>）表示<a href="#Constant_declarations">常量</a>、<a href="#Variable_declarations">变量</a>或<a href="#Function_declarations">函数</a>的非<a href="#Blank_identifier">空白</a>标识符或者一个圆括号括起来的表达式。
</p>

<p>
	<a href="#Blank_identifier">空白标识符</a>只有在<a href="#Assignments">赋值</a>的左侧时才能作为一个操作数。
</p>

<pre class="ebnf">
Operand     = Literal | OperandName | "(" Expression ")" .
Literal     = BasicLit | CompositeLit | FunctionLit .
BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
OperandName = identifier | QualifiedIdent .
</pre>

<h3 id="Qualified_identifiers">限定标识符</h3>

<p>
	限定标识符是由包名前缀所限定的标识符。
	包名和标识符都不能为<a href="#Blank_identifier">空白</a>。
</p>

<pre class="ebnf">
QualifiedIdent = PackageName "." identifier .
</pre>

<p>
	限定标识符可以在不同的包内访问一个标识符，该标识符对应的包必须已经被<a href="#Import_declarations">导入</a>。
	标识符则必须已经在那个包被<a href="#Exported_identifiers">暴露</a>并在<a href="#Blocks">包块</a>中被声明。
</p>

<pre>
math.Sin	// 表示在包 math 中的 Sin 函数
</pre>

<h3 id="Composite_literals">复合字面量</h3>

<p>
	复合字面量为结构体、数组、切片和 map 构造值，并在每次被求值时创建一个新的值。
	复合字面量由字面量类型和紧跟着的花括号绑定的元素列表所组成。
	每个元素可以选择前缀一个对应的键。
</p>

<pre class="ebnf">
CompositeLit  = LiteralType LiteralValue .
LiteralType   = StructType | ArrayType | "[" "..." "]" ElementType |
                SliceType | MapType | TypeName .
LiteralValue  = "{" [ ElementList [ "," ] ] "}" .
ElementList   = KeyedElement { "," KeyedElement } .
KeyedElement  = [ Key ":" ] Element .
Key           = FieldName | Expression | LiteralValue .
FieldName     = identifier .
Element       = Expression | LiteralValue .
</pre>

<p>
	LiteralType 的潜在类型必须是结构体、数组、切片或者 map 类型（文法强制执行此约束，除非类型是作为 TypeName 给出的）。
	元素和键的类型必须是<a href="#Assignability">可分配</a>到字面量类型所对应的字段、元素和键类型的；这里没有额外的转换。
	该键被解释为结构体字面量的字段名，数组和切片字面量的索引，map 字面量的键。
	对于 map 字面量而言，索引元素必须要有一个键。
	给多个元素指定相同的字段名或者不变的键值会出错。
	查阅<a href="#Order_of_evaluation">求值顺序</a>一节获取非常量 map 键的信息。
</p>

<p>
	对结构体字面量来说，应用如下规则：
</p>
<ul>
	<li>键必须为在结构体类型中声明的字段。
	</li>
	<li>不包含任何键的元素列表必须对每个结构体字段（字段声明的顺序）列出一个元素。
	</li>
	<li>只要一个元素有键，那么每个元素都必须要有键。
	</li>
	<li>包含键的元素列表不需要针对每个结构体字段有一个元素。
		省略的字段会获得一个零值。
	</li>
	<li>字面量可以省略元素列表；这样子的字面量相当于其类型的零值。
	</li>
	<li>针对属于不同包的结构体的非暴露字段来指定一个元素是错误的。
	</li>
</ul>

<p>
	给定一个声明
</p>
<pre>
type Point3D struct { x, y, z float64 }
type Line struct { p, q Point3D }
</pre>

<p>
	你可以写
</p>

<pre>
origin := Point3D{}                            // Point3D 为零值
line := Line{origin, Point3D{y: -4, z: 12.3}}  // line.q.x 为零值7
</pre>

<p>
	对数组和切片字面量来说，应用如下规则：
</p>
<ul>
	<li>数组中的每个元素有一个关联的标记其位置的整数索引。
	</li>
	<li>带键的元素使用该键作为其索引。
		这个键必须是可被类型 <code>int</code> 所<a href="#Representability">表示</a>的一个非负常量；而且如果其被赋予了类型的话则必须是整数类型。
	</li>
	<li>不带键的元素使用之前元素的索引加一。如果第一个元素没有键，则其索引为零。
	</li>
</ul>

<p>
	一个复合变量的<a href="#Address_operators">寻址</a>生成了一个到由字面量值初始化的唯一<a href="#Variables">变量</a>的指针。
</p>

<pre>
var pointer *Point3D = &amp;Point3D{y: 1000}
</pre>

<p>
	注意的是，切片和 map 类型的<a href="#The_zero_value">零值</a>不同于同类型的初始化过但为空的值。
	所以，获取空的切片或 map 复合字面量的地址与使用 <a href="#Allocation">new</a> 来分配一个新的切片或 map 的效果不同。
</p>

<pre>
p1 := &amp;[]int{}    // p1 指向一个初始化过的值为 []int{} 长度为 0 的空分片
p2 := new([]int)  // p2 指向一个值为 nil 长度为 0 的未初始化过的分片
</pre>

<p>
	数组字面量的长度是字面量类型所指定的长度。
	在字面量中，如果少于其长度的元素被提供了，那么缺漏的元素会被设置为数组元素类型的零值。
	提供其索引值超出了数组索引范围的元素是错误的。
	符号 <code>...</code> 指定一个数组长度等于其最大元素索引加一。
</p>

<pre>
buffer := [10]string{}             // len(buffer) == 10
intSet := [6]int{1, 2, 3, 5}       // len(intSet) == 6
days := [...]string{"Sat", "Sun"}  // len(days) == 2
</pre>

<p>
	切片字面量描述了整个底层数组字面量。
	因此一个切片字面量的长度和容量为其最大元素索引加一。
	切片字面量的格式为
</p>

<pre>
[]T{x1, x2, … xn}
</pre>

<p>
	以及针对应用到数组的切片操作的简写为：
</p>

<pre>
tmp := [n]T{x1, x2, … xn}
tmp[0 : n]
</pre>

<p>
	在数组、切片或者 map 类型 <code>T</code> 的复合字面量中，如果元素或 map 的键本身为复合字面量，当其字面量类型和 <code>T</code> 的元素或键类型一致时，该字面量类型可以省略。
	类似的，如果元素或键本身为复合字面量的地址，当元素或键的类型为 <code>*T</code> 时，该元素或键可以省略 <code>&amp;T</code>。
</p>

<pre>
[...]Point{{1.5, -3.5}, {0, 0}}     // 同 [...]Point{Point{1.5, -3.5}, Point{0, 0}}
[][]int{{1, 2, 3}, {4, 5}}          // 同 [][]int{[]int{1, 2, 3}, []int{4, 5}}
[][]Point{{{0, 1}, {1, 2}}}         // 同 [][]Point{[]Point{Point{0, 1}, Point{1, 2}}}
map[string]Point{"orig": {0, 0}}    // 同 map[string]Point{"orig": Point{0, 0}}
map[Point]string{{0, 0}: "orig"}    // 同 map[Point]string{Point{0, 0}: "orig"}

type PPoint *Point
[2]*Point{{1.5, -3.5}, {}}          // 同 [2]*Point{&amp;Point{1.5, -3.5}, &amp;Point{}}
[2]PPoint{{1.5, -3.5}, {}}          // 同 [2]PPoint{PPoint(&amp;Point{1.5, -3.5}), PPoint(&amp;Point{})}
</pre>

<p>
	当一个使用 LiteralType 的 TypeName 形式的复合字面量表现为一个在<a href="#Keywords">关键字</a>和 "if"、"for" 或 "switch" 语句块的左花括号之间的操作数，并且该复合字面量不被圆括号、方括号或花括号所包围时，会出现一个解析歧义。
	在这样子一个罕见的情况下，复合字面量的左花括号错误地被解析为语句块的引入。
	为了解决这样子的歧义，这个复合字段必须在圆括号内。
</p>

<pre>
if x == (T{a,b,c}[i]) { … }
if (x == T{a,b,c}[i]) { … }
</pre>

<p>
	有效的数组、切片和 map 字面量的例子：
</p>

<pre>
// 质数列表
primes := []int{2, 3, 5, 7, 9, 2147483647}

// 当 ch 为元音时 vowels[ch] 为真
vowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}

// 数组 [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}
filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}

// 十二平均律以 Hz 为单位的频率（A4 = 440Hz）
noteFrequency := map[string]float32{
	"C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,
	"G0": 24.50, "A0": 27.50, "B0": 30.87,
}
</pre>


<h3 id="Function_literals">函数字面值</h3>

<p>
	函数字面量代表一个匿名<a href="#Function_declarations">函数</a>。
</p>

<pre class="ebnf">
FunctionLit = "func" Signature FunctionBody .
</pre>

<pre>
func(a, b int, z float64) bool { return a*b &lt; int(z) }
</pre>

<p>
	函数字面量可以被赋给一个变量或者直接调用。
</p>

<pre>
f := func(x, y int) int { return x + y }
func(ch chan int) { ch &lt;- ACK }(replyChan)
</pre>

<p>
	函数字面量是<i>闭包</i>：它们可以引用外层函数定义的变量。
	然后这些变量就在外层函数和函数字面量间共享了，并且只要能被访问就可以一直存活。
</p>


<h3 id="Primary_expressions">主表达式</h3>

<p>
	主表达式是一元表达式和二元表达式的操作数。
</p>

<pre class="ebnf">
PrimaryExpr =
	Operand |
	Conversion |
	MethodExpr |
	PrimaryExpr Selector |
	PrimaryExpr Index |
	PrimaryExpr Slice |
	PrimaryExpr TypeAssertion |
	PrimaryExpr Arguments .

Selector       = "." identifier .
Index          = "[" Expression "]" .
Slice          = "[" [ Expression ] ":" [ Expression ] "]" |
                 "[" [ Expression ] ":" Expression ":" Expression "]" .
TypeAssertion  = "." "(" Type ")" .
Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .
</pre>


<pre>
x
2
(s + ".txt")
f(3.1415, true)
Point{1, 2}
m["foo"]
s[i : j + 1]
obj.color
f.p[i].x()
</pre>


<h3 id="Selectors">选择器</h3>

<p>
	针对一个不为<a href="#Package_clause">包名</a>的<a href="#Primary_expressions">主表达式</a> <code>x</code>，<i>选择器表达式</i>
</p>

<pre>
x.f
</pre>

<p>
	表示了值 <code>*x</code>（或者有时候为 <code>*x</code>；见下文）的字段或方法 <code>f</code>。
	标识符 <code>f</code> 被称为（字段或方法）<i>选择器</i>，它一定不能为<a href="#Blank_identifier">空白标识符</a>。
	选择器表达式的类型为 <code>f</code> 的类型。如果 <code>x</code> 是一个包名，看<a href="#Qualified_identifiers">限定标识符</a>一节。
</p>

<p>
	选择器 <code>f</code> 可以表示一个类型 <code>T</code> 的一个字段或方法 <code>f</code>，或者可以指嵌套在 <code>T</code> 中的<a href="#Struct_types">嵌入字段</a>的字段或方法 <code>f</code>。
	遍历以达到 <code>f</code> 所经历的嵌入字段数被称为 <code>f</code> 在 <code>T</code> 中的<i>深度</i>。
	在 <code>T</code> 中声明的字段或者方法 <code>f</code> 的深度为零。
	在 <code>T</code> 中的嵌入字段 <code>A</code> 中声明的字段或者方法 <code>f</code> 的深度为 <code>A</code> 中 <code>f</code> 的深度加一。
</p>

<p>
	以下规则应用于选择器：
</p>

<ol>
<li>
	对于为类型 <code>T</code> 或 <code>*T</code> 的值 <code>x</code> （<code>T</code> 既不是指针类型也不是接口类型），<code>x.f</code> 表示在 <code>T</code> 中最浅深度的字段或者方法 <code>f</code>。
	如果不是恰好<a href="#Uniqueness_of_identifiers">一个 <code>f</code></a> 在最浅深度的话，那么这个选择器表达式就是非法的。
</li>

<li>
	对于为接口类型 <code>I</code> 的值 <code>x</code>，<code>x.f</code> 表示动态值 <code>x</code> 的名为 <code>f</code> 的实际的方法。
	如果在 <code>I</code> 的<a href="#Method_sets">方法集</a>中没有名为 <code>f</code> 的方法，那么这个选择器表达式就是非法的。
</li>

<li>
	例外情况，如果 <code>x</code> 的类型为一个<a href="#Type_definitions">定义的</a>指针类型并且 <code>(*x).f</code> 是一个有效的表示一个字段（但不是方法）的选择器表达式，那么 <code>x.f</code> 是 <code>(*x).f</code> 的简写
</li>

<li>
	在所有其它情况中，<code>x.f</code> 是非法的。
</li>

<li>
	如果 <code>x</code> 是指针类型并且值为 <code>nil</code> 并且 <code>x.f</code> 表示一个结构体字段，那么，给 <code>x.f</code> 赋值或求值会导致一个 <a href="#Run_time_panics">run-time panic</a>。
</li>

<li>
	如果 <code>x</code> 是接口类型并且值为 <code>nil</code>，那么<a href="#Calls">调用</a>或<a href="#Method_values">求值</a>方法 <code>x.f</code> 会导致一个 <a href="#Run_time_panics">run-time panic</a>。
</li>
</ol>

<p>
	举例，给定声明：
</p>

<pre>
type T0 struct {
	x int
}

func (*T0) M0()

type T1 struct {
	y int
}

func (T1) M1()

type T2 struct {
	z int
	T1
	*T0
}

func (*T2) M2()

type Q *T2

var t T2     // 假定 t.T0 != nil
var p *T2    // 假定 p != nil 并且 (*p).T0 != nil
var q Q = p
</pre>

<p>
	你可以写：
</p>

<pre>
t.z          // t.z
t.y          // t.T1.y
t.x          // (*t.T0).x

p.z          // (*p).z
p.y          // (*p).T1.y
p.x          // (*(*p).T0).x

q.x          // (*(*q).T0).x        ((*q).x 是一个有效的字段选择器

p.M0()       // ((*p).T0).M0()      M0 期望接收者 *T0
p.M1()       // ((*p).T1).M1()      M1 期望接收者 T1
p.M2()       // p.M2()              M2 期望接收者 *T2
t.M2()       // (&amp;t).M2()           M2 期望接收者 *T2，查看调用一节
</pre>

<p>
	但下述是无效的：
</p>

<pre>
q.M0()       // (*q).M0 是有效的，但不是字段选择器
</pre>


<h3 id="Method_expressions">方法表达式</h3>

<p>
	如果 <code>M</code> 在类型 <code>T</code> 的<a href="#Method_sets">方法集</a>中，那么 <code>T.M</code> 是一个函数，该函数可以携带和 <code>M</code> 同样的实参像普通函数一样调用，不过会给其前缀一个额外的实参作为该方法的接收者。
</p>

<pre class="ebnf">
MethodExpr    = ReceiverType "." MethodName .
ReceiverType  = Type .
</pre>

<p>
	考虑有两个方法的结构体类型 <code>T</code>，方法一是接收者为类型 <code>T</code> 的 <code>Mv</code>，其二是接收者为类型 <code>*T</code> 的 <code>Mp</code>。
</p>

<pre>
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // 值接收者
func (tp *T) Mp(f float32) float32 { return 1 }  // 指针接收者

var t T
</pre>

<p>
	表达式
</p>

<pre>
T.Mv
</pre>

<p>
	产生一个等同于 <code>Mv</code> 但带一个明确的接收者作为其第一个实参的函数；它的签名为
</p>

<pre>
func(tv T, a int) int
</pre>

<p>
	这个函数可以在带一个明确的接收者情况下被正常地调用，所以以下五种调用是等同的：
</p>

<pre>
t.Mv(7)
T.Mv(t, 7)
(T).Mv(t, 7)
f1 := T.Mv; f1(t, 7)
f2 := (T).Mv; f2(t, 7)
</pre>

<p>
	类似的，表达式
</p>

<pre>
(*T).Mp
</pre>

<p>
	产生一个签名为如下的代表 <code>Mp</code> 的函数值
</p>

<pre>
func(tp *T, f float32) float32
</pre>

<p>
	对于一个带值接收者的方法，可以推导出一个带明确指针接收者的函数，所以
</p>

<pre>
(*T).Mv
</pre>

<p>
	产生一个签名为如下的代表 <code>Mv</code> 的函数值
</p>

<pre>
func(tv *T, a int) int
</pre>

<p>
	这样的一个函数通过接收者创建一个值间接地将其作为接收者传递给底层函数；这个方法在函数调用中不会覆盖那个地址被传递的值。
</p>

<p>
	最后一种情况，值接收者的函数对指针接收者的方法是非法的，因为指针接收者的方法不在该值类型的方法集中。
</p>

<p>
	从方法推导出的函数值是用函数调用语法来调用的；接收者作为调用的第一个实参。也就是，给定 <code>f := T.Mv</code>，<code>f</code> 是作为 <code>f(t, 7)</code> 而非 <code>t.f(7)</code> 被调用的。
	使用<a href="#Function_literals">函数字面量</a>或<a href="#Method_values">方法值</a>来构建一个绑定了接收者的函数。
</p>

<p>
	从一个接口类型的方法中得到一个函数值是合法的。
	所得到的函数使用该接口类型的显式的接收者。
</p>

<h3 id="Method_values">方法值</h3>

<p>
	如果表达式 <code>x</code> 有静态类型 <code>T</code>，并且 <code>M</code> 在类型 <code>T</code> 的<a href="#Method_sets">方法集</a>中，那么 <code>x.M</code> 被称为一个<i>方法值</i>。
	方法值 <code>x.M</code> 是一个可以用与 <code>x.M</code> 的方法调用的相同的实参来调用函数值。
	表达式 <code>x</code> 在该方法值的求值过程中被求值和保存；保存的副本被用在任意调用中（可能会在后续被执行的）作为接收者。
</p>

<p>
	类型 <code>T</code> 可以为接口或者非接口类型。
</p>

<p>
	就像上面<a href="#Method_expressions">方法表达式</a>所讨论的，考虑一个带两个方法的结构体 <code>T</code>，方法一是接收者为类型 <code>T</code> 的 <code>Mv</code>，其二是接收者为类型 <code>*T</code> 的 <code>Mp</code>。
</p>

<pre>
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // 值接收者
func (tp *T) Mp(f float32) float32 { return 1 }  // 指针接收者

var t T
var pt *T
func makeT() T
</pre>

<p>
	表达式
</p>

<pre>
t.Mv
</pre>

<p>
	产生了一个类型如下的函数值
</p>

<pre>
func(int) int
</pre>

<p>
	这两种调用是等同的：
</p>

<pre>
t.Mv(7)
f := t.Mv; f(7)
</pre>

<p>
	类似的，表达式
</p>

<pre>
pt.Mp
</pre>

<p>
	产生了一个类型如下的函数值
</p>

<pre>
func(float32) float32
</pre>

<p>
	就<a href="#Selectors">选择器</a>来说，如果以值作为接收者的非接口方法使用了指针来引用，那么会自动解除到该指针的引用：<code>pt.Mv</code> 等同于 <code>(*pt).Mv</code>。
</p>

<p>
	就<a href="#Calls">方法调用</a>来说，如果以指针作为接收者的非接口方法使用了可寻址值来引用，那么会自动获取该值的地址来引用：<code>t.Mp</code> 等同于 <code>(&amp;t).Mp</code>。
</p>

<pre>
f := t.Mv; f(7)   // 就像 t.Mv(7)
f := pt.Mp; f(7)  // 就像 pt.Mp(7)
f := pt.Mv; f(7)  // 就像 (*pt).Mv(7)
f := t.Mp; f(7)   // 就像 (&amp;t).Mp(7)
f := makeT().Mp   // 无效的: makeT() 的结果是不可寻址的
</pre>

<p>
	虽然以上的例子使用了非接口类型，但是从接口类型的值来创建一个方法值同样是合法的。
</p>

<pre>
var i interface { M(int) } = myVal
f := i.M; f(7)  // 就像 i.M(7)
</pre>


<h3 id="Index_expressions">索引表达式</h3>

<p>
	如下形式的主表达式
</p>

<pre>
a[x]
</pre>

<p>
	表示了可被 <code>x</code> 索引的数组、到数组的指针、切片、字符串或者被 <code>x</code> 索引的 map <code>a</code> 的元素。
	值 <code>x</code> 分别被称为<i>索引</i> 或 <i>map 键</i>。以下规则应用于：
</p>

<p>
	如果 <code>a</code> 不是一个 map：
</p>
<ul>
	<li>索引 <code>x</code> 必须是整数类型或者无类型常量</li>
	<li>常量索引必须为非负且可以被类型 <code>int</code> <a href="#Representability">所表示的</a>的一个值</li>
	<li>无类型的常量索引会被给定一个类型 <code>int</code></li>
	<li>当 <code>0 &lt;= x &lt; len(a)</code> 时，索引 <code>x</code> <i>在范围内</i>，否则它就<i>超出了范围</i></li>
</ul>

<p>
	对于为<a href="#Array_types">数组类型</a> <code>A</code> 的 <code>a</code>：
</p>
<ul>
	<li><a href="#Constants">常量</a>索引必须在范围内</li>
	<li>如果在运行时 <code>x</code> 超出了范围，那么会发生一个<a href="#Run_time_panics">run-time panic</a></li>
	<li><code>a[x]</code> 是一个在索引 <code>x</code> 处的数组元素，且 <code>a[x]</code> 的类型是 <code>A</code> 的元素类型</li>
</ul>

<p>
	对于到数组类型的<a href="#Pointer_types">指针</a> <code>a</code>：
</p>
<ul>
	<li><code>a[x]</code> 是 <code>(*a)[x]</code> 的简写</li>
</ul>

<p>
	对于为<a href="#Slice_types">切片类型</a> <code>S</code> 的 <code>a</code>：
</p>
<ul>
	<li>如果在运行时 <code>x</code> 超出了范围，那么会发生一个 <a href="#Run_time_panics">run-time panic</a></li>
	<li><code>a[x]</code> 是在索引 <code>x</code> 处的切片元素，且 <code>a[x]</code> 的类型是 <code>S</code> 的元素类型</li>
</ul>

<p>
	对于<a href="#String_types">字符串类型</a> <code>a</code>：
</p>
<ul>
	<li>当字符串 <code>a</code> 是常量时，<a href="#Constants">常量</a>索引必须在范围内</li>
	<li>如果在运行时 <code>x</code> 超出了范围，那么会发生一个 <a href="#Run_time_panics">run-time panic</a></li>
	<li><code>a[x]</code> 是在索引 <code>x</code> 处的非常量字节，并且 <code>a[x]</code> 的类型为 <code>byte</code></li>
	<li><code>a[x]</code> 不能被赋值</li>
</ul>

<p>
	对于为<a href="#Map_types">map 类型</a> <code>M</code> 的 <code>a</code>：
</p>
<ul>
	<li><code>x</code> 的类型必须是<a href="#Assignability">可分配</a>为 <code>M</code> 的键类型的</li>
	<li>如果 map 带键为 <code>x</code> 的条目，那么 <code>a[x]</code> 是带键 <code>x</code> 的 map 值，并且 <code>a[x]</code> 的类型为 <code>M</code> 的值类型</li>
	<li>如果 map 为 <code>nil</code> 或者不存这样这样子的一个条目，那么 <code>a[x]</code> 是针对 <code>M</code> 的值类型的<a href="#The_zero_value">零值</a></li>
</ul>

<p>
	其它情况下 <code>a[x]</code> 是非法的。
</p>

<p>
	在类型为 <code>map[K]V</code> 的 map <code>a</code> 中的用在<a href="#Assignments">赋值</a>或特殊格式的初始化中的索引表达式
</p>

<pre>
v, ok = a[x]
v, ok := a[x]
var v, ok = a[x]
</pre>

<p>
	产生了一个额外的无类型的布尔值。当键 <code>x</code> 存在于 map 中时，<code>ok</code> 的值为 <code>true</code>，否则为 <code>false</code>。
</p>

<p>
	给 <code>nil</code> map 的元素赋值会导致一个 <a href="#Run_time_panics">run-time panic</a>。
</p>


<h3 id="Slice_expressions">切片表达式</h3>

<p>
	切片表达式根据字符串、数组、指向数组或切片的指针构建一个子字符串或者切片。
	有两种变体：一种简单的形式，它指定一个下限和一个上限；一种完整的形式，它还指定一个容量的界限。
</p>

<h4>简单的切片表达式</h4>

<p>
	对于一个字符串、数组、到数组的指针或者分片 <code>a</code>，主表达式
</p>

<pre>
a[low : high]
</pre>

<p>
	构造了一个子字符串或者切片。
	索引 <code>low</code> 和 <code>high</code> 选择了操作数 <code>a</code> 的哪些元素作为结果被显示。
	结果有从零开始且长度等于 <code>high</code> - <code>low</code> 的索引。
	在分片了数组 <code>a</code> 后
</p>

<pre>
a := [5]int{1, 2, 3, 4, 5}
s := a[1:4]
</pre>

<p>
	切片 <code>s</code> 有类型 <code>[]int</code>，长度 3，容量 4，以及元素
</p>

<pre>
s[0] == 2
s[1] == 3
s[2] == 4
</pre>

<p>
	为了方便，每一个索引都可能被省略。
	缺少的 <code>low</code> 索引默认为零；缺少的 <code>high</code> 索引默认为被切片的操作数的长度：
</p>

<pre>
a[2:]  // 同 a[2 : len(a)]
a[:3]  // 同 a[0 : 3]
a[:]   // 同 a[0 : len(a)]
</pre>

<p>
	如果 <code>a</code> 为到数组的指针，那么 <code>a[low : high]</code> 为 <code>(*a)[low : high]</code> 的简写。
</p>

<p>
	对于数组或者字符串，如果 <code>0</code> &lt;= <code>low</code> &lt;= <code>high</code> &lt;= <code>len(a)</code>，那么索引是<i>在范围内</i> 的，否则就<i>超出了范围</i>。
	对于切片，上索引边界是切片的容量 <code>cap(a)</code> 而不是其长度。
	<a href="#Constants">常量</a>索引必须为非负且是可以被类型 <code>int</code> <a href="#Representability">所表示的</a>；对于数组和常量字符串而言，常量索引也必须在范围内。
	如果两个索引都是常量，那么它们必须满足 <code>low &lt;= high</code>。
	如果在运行时索引超出了范围，那么会发生<a href="#Run_time_panics">run-time panic</a>。
</p>

<p>
	除了<a href="#Constants">无类型的字符串</a>以外，如果被切片的操作数是一个字符串或者切片，那么切片操作的结果为一个和该操作数具有相同类型的非常量值。
	对于无类型字符串操作数而言，其结果是一个类型为 <code>string</code> 的非常量值。
	如果被切片的操作数是一个数组，那么它必须是<a href="#Address_operators">可被寻址的</a>，并且切片操作的结果为和该数组具有相同元素类型的切片。
</p>

<p>
	如果一个有效的切片表达式的被切片的操作数是一个 <code>nil</code> 切片，那么结果是一个 <code>nil</code> 切片。
	否则，结果会共享该操作数的底层数组。
</p>

<pre>
var a [10]int
s1 := a[3:7]   // s1 的底层数组是数组 a； &s1[2] == &a[5]
s2 := s1[1:4]  // s2 的底层数组是 s1 的底层数组 a； &s2[1] == &a[5]
s2[1] = 42     // s2[1] == s1[2] == a[5] == 42；它们指的都是相同的底层数组元素
</pre>


<h4>完整的切片表达式</h4>

<p>
	对于数组、到数组的指针或者切片 <code>a</code>（不是一个字符串），主表达式
</p>

<pre>
a[low : high : max]
</pre>

<p>
	构成了一个有相同类型的切片，并且带有和简单的切片表达式 <code>a[low : high]</code> 一样的长度和元素。
	此外，它通过设置切片的容量为 <code>max - low</code> 来控制产生的切片的容量。
	只有第一个索引是可以被省略的；默认为零。
	在切片数组 <code>a</code> 后
</p>

<pre>
a := [5]int{1, 2, 3, 4, 5}
t := a[1:3:5]
</pre>

<p>
	切片 <code>t</code> 有类型 <code>[]int</code>，长度 2，容量 4，以及元素
</p>

<pre>
t[0] == 2
t[1] == 3
</pre>

<p>
	和简单的切片表达式一样，如果 <code>a</code> 是一个到数组的指针，那么 <code>a[low : high : max]</code> 是 <code>(*a)[low : high : max]</code> 的简写。
	如果被切片的操作数是一个数组，那么它必须是<a href="#Address_operators">可被寻址的</a>。
</p>

<p>
	如果 <code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code>，那么索引是<i>在范围内</i> 的，否则就<i>超出了范围</i>。
	<a href="#Constants">常量</a>索引必须是非负的且可以被类型 <code>int</code> <a href="#Representability">所代表</a>的值；对于数组，常量索引也必须在范围内。
	如果多个索引为常量，那么存在的常量必须在相对彼此的范围内。
	如果在运行时索引超出了范围，那么会出现一个<a href="#Run_time_panics">run-time panic</a>。
</p>

<h3 id="Type_assertions">类型断言</h3>

<p>
	对于一个<a href="#Interface_types">接口类型</a>的表达式 <code>x</code> 以及一个类型 <code>T</code>，主表达式
</p>

<pre>
x.(T)
</pre>

<p>
	断言 <code>x</code> 不为 <code>nil</code> 并且存储在 <code>x</code> 中的值具有类型 <code>T</code>。
	记法 <code>x.(T)</code> 被称为<i>类型断言</i>。
</p>
<p>
	更准确地来说，如果 <code>T</code> 不是一个接口类型，那么 <code>x.(T)</code> 断言 <code>x</code> 的动态类型和类型 <code>T</code> <a href="#Type_identity">一致</a>。
	在这种情况下，<code>T</code> 必须<a href="#Method_sets">实现</a> <code>x</code> 的（接口）类型；否则类型断言是无效的，因为对于 <code>x</code> 来说存储一个类型为 <code>T</code> 的值是不可能的。
	如果 <code>T</code> 是一个接口类型，那么 <code>x.(T)</code> 断言 <code>T</code> 的动态类型实现了接口 <code>T</code>。
</p>
<p>
	如果类型断言成立，那么表达式的值为存储在 <code>x</code> 中的值，并且其类型为 <code>T</code>。
	如果类型断言不成立，会发生一个 <a href="#Run_time_panics">run-time panic</a>。
	换句话来说，即使 <code>x</code> 的动态类型仅在运行时已知，<code>x.(T)</code> 的类型也可以在一个正确的程序中被已知为 <code>T</code>。
</p>

<pre>
var x interface{} = 7          // x 有动态类型 int 以及值 7
i := x.(int)                   // i 有类型 int 以及值 7

type I interface { m() }

func f(y I) {
	s := y.(string)        // 非法: string 没有实现 I (缺少方法 m)
	r := y.(io.Reader)     // r 有类型 io.Reader ，并且 y 的动态类型必须同时实现 I 和 io.Reader
	…
}
</pre>

<p>
	用于<a href="#Assignments">赋值</a>或如下特殊格式的初始化中的类型断言
</p>

<pre>
v, ok = x.(T)
v, ok := x.(T)
var v, ok = x.(T)
var v, ok T1 = x.(T)
</pre>

<p>
	产生一个额外的无类型的布尔值。
	如果断言成功，那么 <code>ok</code> 的值为 <code>true</code>。
	否则为 <code>false</code>，并且 <code>v</code> 的值为类型 <code>T</code> 的<a href="#The_zero_value">零值</a>。
	这种情况下不会发生 <a href="#Run_time_panics">run-time panic</a>。
</p>


<h3 id="Calls">调用</h3>

<p>
	给定一个函数类型为 <code>F</code> 的表达式 <code>f</code>，
</p>

<pre>
f(a1, a2, … an)
</pre>

<p>
	带实参 <code>a1, a2, … an</code> 调用了 <code>f</code>。
	除了一种特殊情况以外，实参必须是单一值的<a href="#Assignability">可分配</a>给 <code>F</code> 的参数类型的表达式，并且它们在函数调用之前就被求值好了。
	上述函数表达式的类型是 <code>F</code> 的结果类型。
	方法调用是类似的，但是方法本身是被指定为一个在该方法的接收者的值之上的选择器。
</p>

<pre>
math.Atan2(x, y)  // 函数调用
var pt *Point
pt.Scale(3.5)     // 带接收者 pt 的方法调用
</pre>

<p>
	在一个函数调用中，函数值和实参使用<a href="#Order_of_evaluation">通常的顺序</a>执行。
	在它们求值好后，调用的参数以值传递给函数，然后被调用的函数开始执行。
	函数的返回参数在函数返回时以值返回给调用的函数。
</p>

<p>
	调用一个 <code>nil</code> 函数会发生 <a href="#Run_time_panics">run-time panic</a>。
</p>

<p>
	作为一个特殊情况，如果一个函数或方法 <code>g</code> 的返回值数量上等于且可以分别被分配给另一个函数或方法 <code>f</code> 的参数，那么调用 <code>f(g(<i>parameters_of_g</i>))</code> 将会在按序绑定了 <code>g</code> 的返回值到 <code>f</code> 的参数后调用 <code>f</code>。
	<code>f</code> 这个调用必须排除 <code>g</code> 调用以外的参数，并且 <code>g</code> 必须要有最少一个返回值。
	如果 <code>f</code> 有一个最终的 <code>...</code> 参数，这个参数会被分配那些在普通参数赋值完之后的剩余的 <code>g</code> 的返回值。
</p>

<pre>
func Split(s string, pos int) (string, string) {
	return s[0:pos], s[pos:]
}

func Join(s, t string) string {
	return s + t
}

if Join(Split(value, len(value)/2)) != value {
	log.Panic("test fails")
}
</pre>

<p>
	如果 <code>x</code> 的（类型的）<a href="#Method_sets">方法集</a>包含了 <code>m</code>，并且实参列表可以被分配给 <code>m</code> 的形参列表，那么方法调用 <code>x.m()</code> 是有效的。
	如果 <code>x</code> 是<a href="#Address_operators">可被寻址的</a>并且 <code>&amp;x</code> 的方法集包含了 <code>m</code>，那么 <code>x.m()</code> 是 <code>(&amp;x).m()</code> 的简写：
</p>

<pre>
var p Point
p.Scale(3.5)
</pre>

<p>
	这里没有明确的方法类型，也没有方法字面量。
</p>

<h3 id="Passing_arguments_to_..._parameters">传递实参给 <code>...</code> 参数</h3>

<p>
	如果 <code>f</code> 是带最终参数 <code>p</code>（其类型为 <code>...T</code>）的 <a href="#Function_types">variadic</a>，那么在 <code>f</code> 内，<code>p</code> 的类型等同于类型 <code>[]T</code>。
	如果 <code>f</code> 在调用时没有实参给 <code>p</code>，那么传递给 <code>p</code> 的值为 <code>nil</code>。
	否则，传递的值是一个新的类型为 <code>[]T</code> 的切片，这个切片带一个底层数组，这个底层数组的连续的元素作为实参，并且必须<a href="#Assignability">可分配</a>给 <code>T</code>。
	因此该分配的长度和容量是绑定到 <code>p</code> 的实参的数量，而且每次调用可能会不同。
</p>

<p>
	给定函数和调用
</p>
<pre>
func Greeting(prefix string, who ...string)
Greeting("nobody")
Greeting("hello:", "Joe", "Anna", "Eileen")
</pre>

<p>
	在 <code>Greeting</code> 中，<code>who</code> 的值第一次调用时为 <code>nil</code>，在第二次调用时为 <code>[]string{"Joe", "Anna", "Eileen"}</code>。
</p>

<p>
	如果最终的实参可分配给一个切片类型 <code>[]T</code>，那么如果这个实参后跟着 <code>...</code> 的话，它就会在不改变值的情况下传递给一个 <code>...T</code> 参数。
	在这种情况下，不会创建新的切片。
</p>

<p>
	给定一个切片 <code>s</code> 和调用
</p>

<pre>
s := []string{"James", "Jasmine"}
Greeting("goodbye:", s...)
</pre>

<p>
	在 <code>Greeting</code> 内，<code>who</code> 有和 <code>s</code> 有同一个值和同一个底层数组。
</p>


<h3 id="Operators">运算符</h3>

<p>
	运算符把操作数结合进一个表达式。
</p>

<pre class="ebnf">
Expression = UnaryExpr | Expression binary_op Expression .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = "||" | "&amp;&amp;" | rel_op | add_op | mul_op .
rel_op     = "==" | "!=" | "&lt;" | "&lt;=" | ">" | ">=" .
add_op     = "+" | "-" | "|" | "^" .
mul_op     = "*" | "/" | "%" | "&lt;&lt;" | "&gt;&gt;" | "&amp;" | "&amp;^" .

unary_op   = "+" | "-" | "!" | "^" | "*" | "&amp;" | "&lt;-" .
</pre>

<p>
	比较运算符会在<a href="#Comparison_operators">其它地方</a>讨论。
	对于其它二元运算符来说，操作数类型必须是<a href="#Type_identity">一致的</a>，除非运算涉及位移或者无类型的<a href="#Constants">常量</a>。
	对于只涉及常量的运算，看<a href="#Constant_expressions">常量表达式</a>一节。
</p>

<p>
	除了位移运算之外，如果一个操作数是无类型<a href="#Constants">常量</a>而另一个操作数不是，那么该常量会被隐式地<a href="#Conversions">转换</a>为另一个操作数的类型。
</p>

<p>
	在位移表达式的右侧的操作数必须为整数类型，或者可以被 <code>uint</code> 类型的值<a href="#Representability">所表示的</a>无类型的常量。
	如果一个非常量位移表达式的左侧的操作数是一个无符号常量，那么它会先被隐式地转换为假如位移表达式被其左侧操作数单独替换后的类型。
</p>

<pre>
var s uint = 33
var i = 1&lt;&lt;s                  // 1 的类型为 int
var j int32 = 1&lt;&lt;s            // 1 的类型为 int32; j == 0
var k = uint64(1&lt;&lt;s)          // 1 的类型为 uint64; k == 1<<33
var m int = 1.0&lt;&lt;s            // 1.0 的类型为 int; 如果此处 int 为 32 比特大小的话， m == 0
var n = 1.0&lt;&lt;s == j           // 1.0 的类型为 int32; n == true
var o = 1&lt;&lt;s == 2&lt;&lt;s          // 1 和 2 的类型为 int; 如果此处 int 为 32 比特大小的话， o == true
var p = 1&lt;&lt;s == 1&lt;&lt;33         // 如果 int 的大小为 32 位，则为非法：1 的类型为 int，但 1<<33 溢出 int
var u = 1.0&lt;&lt;s                // 非法: 1.0 的类型为 float64, 不能位移
var u1 = 1.0&lt;&lt;s != 0          // 非法: 1.0 的类型为 float64, 不能位移
var u2 = 1&lt;&lt;s != 1.0          // 非法: 1 的类型为 float64, 不能位移
var v float32 = 1&lt;&lt;s          // 非法: 1 的类型为 float32, 不能位移
var w int64 = 1.0&lt;&lt;33         // 1.0<<33 是一个常量位移表达式
var x = a[1.0&lt;&lt;s]             // 1.0 的类型为 int；如果 int 是 32 位的话， x == a[0]
var a = make([]byte, 1.0&lt;&lt;s)  // 1.0 的类型为 int；如果 int 是 32 位的话， len(a) == 0
</pre>


<h4 id="Operator_precedence">运算符优先级</h4>
<p>
	一元运算符有最高的优先级。
	由于 <code>++</code> 和 <code>--</code> 运算符构成了语句（而不是表达式），超出了运算符的结构。
	因此，语句 <code>*p++</code> 等同于 <code>(*p)++</code>。
</p>

<p>
	对于二元运算符来说有五个优先级。
	乘法运算符束缚力最强，接下来是加法运算符，比较运算符，<code>&amp;&amp;</code>（逻辑与），和最后的 <code>||</code>（逻辑或）：
</p>

<pre class="grammar">
Precedence    Operator
    5             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^
    4             +  -  |  ^
    3             ==  !=  &lt;  &lt;=  &gt;  &gt;=
    2             &amp;&amp;
    1             ||
</pre>

<p>
	同一优先级的二元运算符按从左到右的顺序结合。比如，<code>x / y * z</code> 等同于 <code>(x / y) * z</code>。
</p>

<pre>
+x
23 + 3*x[i]
x &lt;= f()
^a &gt;&gt; b
f() || g()
x == y+1 &amp;&amp; &lt;-chanPtr &gt; 0
</pre>


<h3 id="Arithmetic_operators">算数运算符</h3>
<p>
	算数运算符应用于数字值，并产生一个和第一个操作数具有相同类型的结果。
	四个标准的算数运算符（<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>）应用于整数、浮点数和复数类型，<code>+</code> 还可以应用于字符串。
	位逻辑运算符和位移运算符仅应用于整数。
</p>

<pre class="grammar">
+    和                    	整数，浮点数，复数值，字符串
-    差             		整数，浮点数，复数值
*    积                		整数，浮点数，复数值
/    商               		整数，浮点数，复数值
%    余          		    整数

&amp;    按位与（AND）          	整数
|    按位或（OR）         	整数
^    按位异或（XOR）          整数
&amp;^   按位清除（AND NOT）    	整数

&lt;&lt;   向左位移            	整数 << 无符号整数
&gt;&gt;   向右位移            	整数 >> 无符号整数
</pre>


<h4 id="Integer_operators">整数运算符</h4>

<p>
	对于两个整数值 <code>x</code> 和 <code>y</code>，其整数商 <code>q = x / y</code> 和余数 <code>r = x % y</code> 满足如下关系：
</p>

<pre>
x = q*y + r  and  |r| &lt; |y|
</pre>

<p>
	随着 <code>x / y</code> 截断到零（<a href="https://en.wikipedia.org/wiki/Modulo_operation">"截断除法"</a>）。
</p>

<pre>
 x     y     x / y     x % y
 5     3       1         2
-5     3      -1        -2
 5    -3      -1         2
-5    -3       1        -2
</pre>

<p>
	这个规则有一个例外，如果对于 <code>x</code> 的整数类型来说，被除数 <code>x</code> 是该类型中最负的那个值，那么，因为二进制补码的<a href="#Integer_overflow">整数溢出</a>，商 <code>q = x / -1</code> 等于 <code>x</code>（并且 <code>r = 0</code>）：
</p>

<pre>
			 x, q
int8                     -128
int16                  -32768
int32             -2147483648
int64    -9223372036854775808
</pre>

<p>
	如果除数是一个<a href="#Constants">常量</a>，那么它一定不能为零。
	如果在运行时除数为零，那么会发生一个<a href="#Run_time_panics">run-time panic</a>。
	如果被除数不为负值并且除数可以表示为以 2 为底数的一个次方常量，那么除法可以被向右位移所替换，计算余数可以被按位与运算符所替换：
</p>

<pre>
 x     x / 4     x % 4     x &gt;&gt; 2     x &amp; 3
 11      2         3         2          3
-11     -2        -3        -3          1
</pre>

<p>
	位移运算符通过右侧操作数（必须为非负）所指定的位移数来位移左侧的操作数。
	如果在运行时位移数为负，那么会发生一个 <a href="#Run_time_panics">run-time panic</a>。
	如果左侧操作数是一个带符号的整数，那么位移运算符实现算数位移；如果是一个不带符号的整数，那么实现逻辑位移。
	位移数是没有上限的。
	对于 <code>n</code> 个位移数来说，位移行为犹如左侧操作数以间隔 1 来位移 <code>n</code> 次。
	因此，<code>x &lt;&lt; 1</code> 等于 <code>x*2</code> 而 <code>x &gt;&gt; 1</code> 等于 <code>x/2</code>，不过向右位移会向负无穷截断。
</p>

<p>
	对于整数操作数，一元运算符 <code>+</code>，<code>-</code> 和 <code>^</code> 有如下定义：
</p>

<pre class="grammar">
+x                          是 0 + x
-x    取其负值             	是 0 - x
^x    按位补码    			是 m ^ x  对于无符号x，m = "所有位都设置为 1"，对于有符号 x，m = -1
</pre>


<h4 id="Integer_overflow">整数溢出</h4>

<p>
	对于无符号整数值来说，<code>+</code>，<code>-</code>，<code>*</code> 和 <code>&lt;&lt;</code> 运算是以 2<sup><i>n</i></sup> 为模来计算的，<i>n</i> 为<a href="#Numeric_types">无符号整数</a>类型的位宽。
	大致来说就是，这些无符号整数运算丢弃了溢出的高位，并且程序可以依赖于 "wrap around"。
</p>
<p>
	对于带符号整数值来说，<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code> 和 <code>&lt;&lt;</code> 运算可以合法地溢出，其产生的值是存在的并且可以被带符号整数表示法、其运算和操作数明确地定义。
	溢出不会发生 <a href="#Run_time_panics">run-time panic</a>。
	编译器不会在不发生溢出这个假设情况下来优化代码。
	比如，它不会假设 <code>x &lt; x + 1</code> 始终是真。
</p>


<h4 id="Floating_point_operators">浮点运算符</h4>

<p>
	对于浮点数和复数来说，<code>+x</code> 和 <code>x</code> 是一样的，但是 <code>-x</code> 是负的 <code>x</code>。
	除了 IEEE-754 标准外，没有规定浮点数或者复数除以零的值；是否发生 <a href="#Run_time_panics">run-time panic</a> 是由具体实现规定的。
</p>

<p>
	某个实现可能会在声明中结合多个浮点运算符为单一的融合运算符，然后产生一个与单独执行指令再取整所不同的值。
	一个显示的浮点类型<a href="#Conversions">转换</a>会约到目标类型的精度，避免了融合会丢弃该舍入。
</p>

<p>
	比如，有些架构提供了一个“积和熔加运算”（FMA）指令，该指令在运算 <code>x*y + z</code> 是不会先约取中间结果 <code>x*y</code>。
	这些例子展示了什么时候 Go 实现会使用这个指令：
</p>

<pre>
// FMA 允许被用来计算 r, 因为 x*y 不会被明确地约取：
r  = x*y + z
r  = z;   r += x*y
t  = x*y; r = t + z
*p = x*y; r = *p + z
r  = x*y + float64(z)

// FMA 不允许被用来计算 r, 因为它会省略 x*y 的舍入:
r  = float64(x*y) + z
r  = z; r += float64(x*y)
t  = float64(x*y); r = t + z
</pre>

<h4 id="String_concatenation">字符串连接</h4>

<p>
	字符串使用使用 <code>+</code> 运算符或者 <code>+=</code> 赋值运算符来连接。
</p>

<pre>
s := "hi" + string(c)
s += " and good bye"
</pre>

<p>
	字符串加法通过连接操作数来创建了一个新的字符串。
</p>


<h3 id="Comparison_operators">比较运算符</h3>

<p>
	比较运算符比较两个操作数，然后产生一个无类型的布尔值。
</p>

<pre class="grammar">
==    等于
!=    不等于
&lt;     小于
&lt;=    小于等于
&gt;     大于
&gt;=    大于等于
</pre>

<p>
	在每一个比较中，第一个操作数必须是<a href="#Assignability">可分配</a>给第二个操作数的类型的，或者反过来。
</p>
<p>
	相等运算符 <code>==</code> 和 <code>!=</code> 应用到<i>可比较的</i> 操作数上。
	排序运算符 <code>&lt;</code>，<code>&lt;=</code>，<code>&gt;</code> 或 <code>&gt;=</code> 应用到<i>可排序的</i> 操作数上。
	术语以及比较的结果定义如下：
</p>

<ul>
	<li>
		布尔值是可比较的。如果两个布尔值都为 <code>true</code> 或者 <code>false</code>，那么它们相等。
	</li>

	<li>
		通常情况下，整数值是可比较且可排序的。
	</li>

	<li>
		浮点数值是可比较且可排序的，就像 IEEE-754 标准定义的。
	</li>

	<li>
		复数值是可比较的。
		如果存在两个复数值 <code>u</code> 和 <code>v</code>，满足 <code>real(u) == real(v)</code> 并且 <code>imag(u) == imag(v)</code> 的话，那么它们相等。
	</li>

	<li>
		字符串值是可按字节顺序比较且排序的（按照字节的词法）。
	</li>

	<li>
		指针值是可比较的。
		如果两个指针指向同一个变量，或者两个都为 <code>nil</code> 的话，那么它们相等。
		指向不同<a href="#Size_and_alignment_guarantees">零值</a>变量的指针可能相同也可能不同。
	</li>

	<li>
		Channel 值是可比较的。如果两个 Channel 值由同一个 <a href="#Making_slices_maps_and_channels"><code>make</code></a> 调用来创建或者两个的值都为 <code>nil</code>，那么它们相同。
	</li>

	<li>
		接口值是可比较的。
		如果两个接口值有<a href="#Type_identity">一致的</a>动态类型以及相同的动态值，或者两个的值都为 <code>nil</code>，那么它们相同。
	</li>

	<li>
		当非接口类型 <code>X</code> 的值是可比较的且 <code>x</code> 实现了接口类型 <code>T</code>，那么 <code>X</code> 的值 <code>x</code> 和 <code>T</code> 的值 <code>t</code> 是可比较的。
		如果 <code>t</code> 的动态类型和 <code>X</code> 一致并且 <code>t</code> 的动态值等于 <code>x</code> 的话，那么它们相等。
	</li>

	<li>
		当结构体的所有字段都是可比较的，那么该结构体是可比较的。
		如果两个结构体的对应的非<a href="#Blank_identifier">空白</a>字段相等，那么两个结构体相等。
	</li>

	<li>
		如果数组的元素值是可比较的，那么该数组是可比较的。如果两个数组对应的元素是相等的，那么两个数组相等。
	</li>
</ul>

<p>
	当两个比较中的接口值的动态类型一致，但是该类型的值是不可比较的时候，会发生一个 <a href="#Run_time_panics">run-time panic</a>。
	这种情况不仅仅发生在接口值比较上，同样也会发生在比较接口值数组或者带接口值字段的结构体上。
</p>

<p>
	切片、map 和函数值是不可比较的。
	不过作为一个特例，一个切片、map 或者函数值可以和预先声明的标识符 <code>nil</code> 来比较。
	指针、channel 和接口值与 <code>nil</code> 的比较也是允许的，并遵循上述通用规则。
</p>

<pre>
const c = 3 &lt; 4            // c 是无类型布尔常量"真"

type MyBool bool
var x, y int
var (
	// 比较的结果为一个无类型的布尔值。
	// 应用通用赋值规则。
	b3        = x == y // b3 类型为 bool
	b4 bool   = x == y // b4 类型为 bool
	b5 MyBool = x == y // 类型为 MyBool
)
</pre>

<h3 id="Logical_operators">逻辑运算符</h3>

<p>
	逻辑运算符应用于<a href="#Boolean_types">布尔</a>值，并产生一个和操作数相同类型的结果。
	右侧的操作数是按条件来求值的。
</p>

<pre class="grammar">
&amp;&amp;    conditional AND    p &amp;&amp; q  is  "if p then q else false"
||    conditional OR     p || q  is  "if p then true else q"
!     NOT                !p      is  "not p"
</pre>


<h3 id="Address_operators">地址运算符</h3>

<p>
	对于类型为 <code>T</code> 的操作数 <code>x</code> 来说，地址运算 <code>&amp;x</code> 生成了一个类型为 <code>*T</code> 的到 <code>x</code> 的指针。
	该操作数必须是<i>可被寻址的</i>，也就是，一个变量、指针间接 pointer indirection、或切片索引操作；或一个可寻址的结构体操作数的字段选择器；或一个可寻址的数组的数组索引操作。
	作为可被寻址要求的一个例外，<code>x</code> 也可以是（可能是括起来的）复合字面值。
	如果 <code>x</code> 的求值会导致一个 <a href="#Run_time_panics">run-time panic</a>，那么 <code>&amp;x</code> 的求值也会。
</p>

<p>
	对于指针类型 <code>*T</code> 的操作数 <code>x</code> 来说，指针间接 <code>*x</code> 表示被 <code>x</code> 指向的类型为 <code>T</code> 的<a href="#Variables">变量</a>。
	如果 <code>x</code> 是 <code>nil</code>，那么对于 <code>*x</code> 的求值尝试会导致一个 <a href="#Run_time_panics">run-time panic</a>。
</p>

<pre>
&amp;x
&amp;a[f(2)]
&amp;Point{2, 3}
*p
*pf(x)

var x *int = nil
*x   // 导致一个 run-time panic
&amp;*x  // 导致一个 run-time panic
</pre>


<h3 id="Receive_operator">接收运算符</h3>

<p>
	对于 <a href="#Channel_types">channel 类型</a>的操作数 <code>ch</code> 来说，接收操作 <code>&lt;-ch</code> 的值是从 channel <code>ch</code> 接收到的值。
	channel 方向必须允许接收操作，并且接收操作的类型为 channel 的元素类型。
	直到一个值可用前该表达式都会阻塞。
	从一个 <code>nil</code> channel 接收值会永远阻塞下去。
	针对一个 <a href="#Close">closed</a> channel 的接收操作总是会立即进行，并在之前已经发送完成的值被接收完毕后产生一个该元素类型的<a href="#The_zero_value">零值</a>。
</p>

<pre>
v1 := &lt;-ch
v2 = &lt;-ch
f(&lt;-ch)
&lt;-strobe  // 等待，直到时钟脉冲一次，并丢弃接收的值
</pre>

<p>
	用于<a href="#Assignments">赋值</a>或特殊格式的初始化中的接收表达式
</p>

<pre>
x, ok = &lt;-ch
x, ok := &lt;-ch
var x, ok = &lt;-ch
var x, ok T = &lt;-ch
</pre>

<p>
	产生一个额外的无类型的布尔值用于报告通信是否成功。
	如果接收的值被到该 channel 的成功的发送操作传递过来，那么 <code>ok</code> 的值为 <code>true</code>，如果因为该 channel 已经关闭且为空，接收到的是零值，那么 <code>ok</code> 为 <code>false</code>。
</p>


<h3 id="Conversions">转换</h3>

<p>
	转换会把一个表达式的<a href="#Types">类型</a>变成被该转换所指定的类型。
	一个转换可能会从字面上出现在源中，也可能<i>隐含在</i> 表达式所在的上下文中。
</p>

<p>
	一个<i>显式的</i> 转换是 <code>T(x)</code> 这样子形式的表达式，其中 <code>T</code> 是一个类型而 <code>x</code> 是一个可以被转换到类型 <code>T</code> 的一个表达式。
</p>

<pre class="ebnf">
Conversion = Type "(" Expression [ "," ] ")" .
</pre>

<p>
	如果类型由运算符 <code>*</code> 或者 <code>&lt;-</code> 开头，或者由关键字 <code>func</code> 开头并且没有结果列表，那么当必要时它必须被括起来以避免混淆：
</p>

<pre>
*Point(p)        // 同 *(Point(p))
(*Point)(p)      // p 被转换为 *Point
&lt;-chan int(c)    // 同 &lt;-(chan int(c))
(&lt;-chan int)(c)  // 同 <-(chan int(c))
func()(x)        // 函数签名 func() x
(func())(x)      // x 被转换为 func()
(func() int)(x)  // x 被转换为 func() int
func() int(x)    // x 被转换为 func() int (非歧义表达式)
</pre>

<p>
	如果一个<a href="#Constants">常量</a>值 <code>x</code> 可以被类型为 <code>T</code> 的值<a href="#Representability">所表示</a>，那么 <code>x</code> 可以被转换为 <code>T</code>。
	特殊情况下，整数常量 <code>x</code> 可以使用像非常量 <code>x</code> <a href="#Conversions_to_and_from_a_string_type">一样的规则</a>被显示地转换为<a href="#String_types">字符串类型</a>。
</p>

<p>
	常量转换产生一个带类型的常量来作为结果。
</p>

<pre>
uint(iota)               // unit 类型的 iota 值
float32(2.718281828)     // float32 类型的 2.718281828
complex128(1)            // complex128 类型的 1.0 + 0.0i
float32(0.49999999)      // float32 类型的 0.5
float64(-1e-1000)        // float64 类型的 0.0
string('x')              // string 类型的 "x"
string(0x266c)           // string 类型的 "♬"
MyString("foo" + "bar")  // MyString 类型的 "foobar"
string([]byte{'a'})      // 不是常量: []byte{'a'} 不是常量
(*int)(nil)              // 不是常量: nil 不是常量， *int 不是布尔、数值或字符串类型
int(1.2)                 // 非法: 1.2 不能被 int 表示
string(65.0)             // 非法: 65.0 不是整数常量
</pre>

<p>
	非常量值 <code>x</code> 在以下这些情况下可以被转换为类型 <code>T</code>：
</p>

<ul>
	<li>
		<code>x</code> <a href="#Assignability">可分配</a>给 <code>T</code>。
	</li>
	<li>
		忽略结构体标签（见下文），<code>x</code> 的类型和 <code>T</code> 有<a href="#Type_identity">一致的</a><a href="#Types">潜在类型</a>。
	</li>
	<li>
		忽略结构体标签（见下文），<code>x</code> 的类型和 <code>T</code> 都不是<a href="#Type_definitions">定义的</a>指针类型，并且它们的基础类型有一致的潜在类型。
	</li>
	<li>
		<code>x</code> 的类型和 <code>T</code> 都是整数或者浮点数类型。
	</li>
	<li>
		<code>x</code> 的类型和 <code>T</code> 都是复数类型。
	</li>
	<li>
		<code>x</code> 是一个整数或一个字节或 rune 切片，并且 <code>T</code> 是字符串类型。
	</li>
	<li>
		<code>x</code> 是一个字符串并且 <code>T</code> 是一个字节或者 rune 切片。
	</li>
</ul>

<p>
	在为了转换的目的而比较结构体类型是否一致时，<a href="#Struct_types">结构体的标签</a>是被忽略的：
</p>

<pre>
type Person struct {
	Name    string
	Address *struct {
		Street string
		City   string
	}
}

var data *struct {
	Name    string `json:"name"`
	Address *struct {
		Street string `json:"street"`
		City   string `json:"city"`
	} `json:"address"`
}

var person = (*Person)(data)  // 忽略标签，潜在类型是一致的
</pre>

<p>
	数字类型之间或者数字类型和字符串类型之间的（非常量）转换有特殊的规则。
	这些转换可能改变 <code>x</code> 的表现方式并产生运行时成本。
	所有其它的转换仅改变其类型而不会改变 <code>x</code> 的表现形式。
</p>

<p>
	没有语言机制可以在指针和整数间做转换。
	在一些受限制的情况下，包 <a href="#Package_unsafe"><code>unsafe</code></a> 实现了这个功能。
</p>

<h4>数字类型间的转换</h4>

<p>
	以下的规则应用于非常量数值间的转换：
</p>

<ol>
<li>
	当在整数类型间做转换时，如果值是一个带符号整数，那么它会用符号位扩展到隐式的无限精度；否则它会用零扩展。
	然后它会截断以满足结果类型的大小。
	比如，如果 <code>v := uint16(0x10F0)</code>，那么 <code>uint32(int8(v)) == 0xFFFFFFF0</code>。
	这种转换总是会产生一个有效的值；也不会有溢出指示。
</li>
<li>
	当转换浮点数到整数时，小数部分会被丢弃（截断到零）。
</li>
<li>
	当转换整数或者浮点数到浮点数类型，或者复数到其它复数类型时，结果值会约到目标类型所规定的精度。
	比如，<code>float32</code> 类型变量 <code>x</code> 的值可能使用超过 IEEE-754 32 位数的精度保存着，但是 float32(x) 表示的是把 <code>x</code> 的值约到 32 位精度的结果。
	类似的，<code>x + 0.1</code> 可能使用了超过 32 位精度，但是 <code>float32(x + 0.1)</code> 则不然。
</li>
</ol>

<p>
	在所有涉及浮点数或复数的非常量转换中，如果结果类型不能表示转换后的值，转换依旧是成功的，但结果值依赖实现。
</p>

<h4 id="Conversions_to_and_from_a_string_type">字符串类型之间的转换</h4>

<ol>
<li>
	将有符号或无符号整数值转换为字符串类型会产生一个包含整数的UTF-8表示形式的字符串
	超过有效 Unicode 码位范围的值会被转换为 <code>"\uFFFD"</code>。

<pre>
string('a')       // "a"
string(-1)        // "\ufffd" == "\xef\xbf\xbd"
string(0xf8)      // "\u00f8" == "ø" == "\xc3\xb8"
type MyString string
MyString(0x65e5)  // "\u65e5" == "日" == "\xe6\x97\xa5"
</pre>
</li>

<li>
	转换字节切片到字符串类型会产生一个以该切片的元素作为连续字节的字符串。

<pre>
string([]byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'})   // "hellø"
string([]byte{})                                     // ""
string([]byte(nil))                                  // ""

type MyBytes []byte
string(MyBytes{'h', 'e', 'l', 'l', '\xc3', '\xb8'})  // "hellø"
</pre>
</li>

<li>
	转换 rune 切片到字符串会产生一个把独立的 rune 值转换为 string 后再串联的字符串。

<pre>
string([]rune{0x767d, 0x9d6c, 0x7fd4})   // "\u767d\u9d6c\u7fd4" == "白鵬翔"
string([]rune{})                         // ""
string([]rune(nil))                      // ""

type MyRunes []rune
string(MyRunes{0x767d, 0x9d6c, 0x7fd4})  // "\u767d\u9d6c\u7fd4" == "白鵬翔"
</pre>
</li>

<li>
	转换字符串类型的值到字节类型的切片会产生一个以该字符串的字节作为连续元素的切片。

<pre>
[]byte("hellø")   // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
[]byte("")        // []byte{}

MyBytes("hellø")  // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
</pre>
</li>

<li>
	转换字符串类型到 rune 类型切片会产生一个包含该字符串独立 Unicode 码位的切片。

<pre>
[]rune(MyString("白鵬翔"))  // []rune{0x767d, 0x9d6c, 0x7fd4}
[]rune("")                 // []rune{}

MyRunes("白鵬翔")           // []rune{0x767d, 0x9d6c, 0x7fd4}
</pre>
</li>
</ol>


<h3 id="Constant_expressions">常量表达式</h3>

<p>
	常量表达式仅包含<a href="#Constants">常量</a>操作数，且是在编译的时候进行计算的。
</p>

<p>
	不管以布尔、数字或者字符串类型作为操作数是否合法，使用对应的无类型的布尔、数字和字符串常量作为操作数是可以的。
</p>

<p>
	常量<a href="#Comparison_operators">比较</a>总是会产生一个无类型的布尔常量。
	如果常量<a href="#Operators">位移表达式</a>的左侧操作数是一个无类型常量，那么其结果是一个整数常量；否则就是和左侧操作数同一类型的常量（必须是<a href="#Numeric_types">整数类型</a>）。
</p>

<p>
	任何其它在无类型常量上的操作结果是同一个类别的无类型常量；也就是：布尔、整数、浮点数、复数或者字符串常量。
	如果一个二元运算（非位移）的无类型操作数是不同类的，那么其结果是在如下列表中靠后显示的操作数的类：整数、rune、浮点数、复数。
	举例：无类型整数常量除以无类型复数常量会产生一个无类型的复数常量。
</p>

<pre>
const a = 2 + 3.0          // a == 5.0   (无类型浮点数常量)
const b = 15 / 4           // b == 3     (无类型整数常量)
const c = 15 / 4.0         // c == 3.75  (无类型浮点数常量)
const Θ float64 = 3/2      // Θ == 1.0   (类型为 float64, 3/2 是整数除法)
const Π float64 = 3/2.     // Π == 1.5   (类型为 float64, 3/2. 是浮点除法)
const d = 1 &lt;&lt; 3.0         // d == 8     (无类型整数常量)
const e = 1.0 &lt;&lt; 3         // e == 8     (无类型整数常量)
const f = int32(1) &lt;&lt; 33   // illegal    (常量 8589934592 对于 int32 来说溢出了)
const g = float64(2) &gt;&gt; 1  // illegal    (float64(2) 是一个带类型的浮点数常量)
const h = "foo" &gt; "bar"    // h == true  (无类型布尔常量)
const j = true             // j == true  (无类型布尔常量)
const k = 'w' + 1          // k == 'x'   (无类型 rune 常量)
const l = "hi"             // l == "hi"  (无类型字符串常量)
const m = string(k)        // m == "x"   (字符串类型)
const Σ = 1 - 0.707i       //            (无类型复数常量)
const Δ = Σ + 2.0e-4       //            (无类型复数常量)
const Φ = iota*1i - 1/1i   //            (无类型复数常量)
</pre>

<p>
	把内置函数 <code>complex</code> 应用到无类型整数、rune 或者浮点数常量会产生一个无类型的复数常量。
</p>

<pre>
const ic = complex(0, c)   // ic == 3.75i  (无类型复数常量)
const iΘ = complex(0, Θ)   // iΘ == 1i     (complex128 类型)
</pre>

<p>
	常量表达式总是会被精确地求值；中间值和常量本身可能会需求比任何在语言中预定义的类型所支持的更大的精度。
	以下都是合法的声明：
</p>

<pre>
const Huge = 1 &lt;&lt; 100         // Huge == 1267650600228229401496703205376  (无类型整数常量)
const Four int8 = Huge &gt;&gt; 98  // Four == 4                                (int8 类型)
</pre>

<p>
	常量除法或取余操作的除数一定不能是零：
</p>

<pre>
3.14 / 0.0   // 非法的：除数不能为零
</pre>

<p>
	<i>带类型的</i> 的常量的值必须是能被该常量类型所精确得<a href="#Representability">表示的</a>。
	以下常量表达式是非法的：
</p>

<pre>
uint(-1)     // -1 不能作为 uint 来表示
int(3.14)    // 3.14 不能作为 int 来表示
int64(Huge)  // 1267650600228229401496703205376 不能作为 int64 来表示
Four * 300   // 操作数 300 不能作为 int8 (Four 的类型) 来表示
Four * 100   // 乘积 400 不能作为 int8 (Four 的类型) 来表示
</pre>

<p>
	用于一元按位补码运算符 <code>^</code> 的掩码符合非常量的规则：对于无符号常量来说所有位都是 1，而对于带符号且无类型的常量来说，则是一个 -1。
</p>

<pre>
^1         // 无类型整数常量，等于 -2
uint8(^1)  // 非法的: 相当于 uint8(-2)， -2 不能被 uint8 所表示
^uint8(1)  // 带类型的 uint8 常量， 相当于 0xFF ^ uint8(1) = uint8(0xFE)
int8(^1)   // 相当于 int8(-2)
^int8(1)   // 相当于 -1 ^ int8(1) = -2
</pre>

<p>
	实现限制：编译器可能会在计算无类型浮点数或者复数常量表达式时凑整；请参阅<a href="#Constants">常量</a>一节中的实现限制。
	该凑整可能导致在整数上下文内的浮点数常量表达式失效，即使它将在使用无限精度计算时是不可或缺的，反之亦然。
</p>


<h3 id="Order_of_evaluation">求值顺序</h3>

<p>
	在包的级别上，<a href="#Package_initialization">初始化依赖</a>确定了<a href="#Variable_declarations">变量声明</a>中独立的初始化表达式的求值顺序。
	其它方面，当对表达式、赋值或者 <a href="#Return_statements">return 语句</a>的<a href="#Operands">操作数</a>进行求值时，所有的函数调用、方法调用和通讯操作都是以词法的从左至右的顺序执行的。
</p>

<p>
	比如，在（函数本地）赋值
</p>
<pre>
y[f()], ok = g(h(), i()+x[j()], &lt;-c), k()
</pre>
<p>
	函数调用和通讯是按照 <code>f()</code>，<code>h()</code>，<code>i()</code>，<code>j()</code>，<code>&lt;-c</code>，<code>g()</code> 和 <code>k()</code> 的顺序发生的。
	不过，以上这些事件相比较于 <code>x</code> 的求值和索引，以及 <code>y</code> 的求值的顺序则是没有规定的。
</p>

<pre>
a := 1
f := func() int { a++; return a }
x := []int{a, f()}            // x 可以是 [1, 2] 或是 [2, 2]： a 和 f() 的求值顺序没有被规定
m := map[int]int{a: 1, a: 2}  // m 可以是 {2: 1} 或是 {2: 2}： 两个映射赋值的求值顺序没有被规定
n := map[int]int{a: f()}      // n 可以是 {2: 3} 或是 {3: 3}： 键和值的求值顺序没有被规定
</pre>

<p>
	在包的级别上，初始化依赖会覆盖掉针对独立初始化表达式的从左至右的规则，但是不会针对在每个表达式中的操作数：
</p>

<pre>
var a, b, c = f() + v(), g(), sqr(u()) + v()

func f() int        { return c }
func g() int        { return a }
func sqr(x int) int { return x*x }

// 函数 u 和 v 独立于其它所有的变量和函数
</pre>

<p>
	函数调用是按照 <code>u()</code>，<code>sqr()</code>，<code>v()</code>，<code>f()</code>，<code>v()</code> and <code>g()</code> 的顺序发生的。
</p>

<p>
	在单一表达式中的浮点数操作是根据运算符的结合性来求值的。
	明确的括号会通过覆盖默认的结合性来影响求值。
	在表达式 <code>x + (y + z)</code> 中，加法 <code>y + z</code> 在加 <code>x</code> 前被执行。
</p>

<h2 id="Statements">语句</h2>

<p>
	语句控制着执行。
</p>

<pre class="ebnf">
Statement =
	Declaration | LabeledStmt | SimpleStmt |
	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
	DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
</pre>

<h3 id="Terminating_statements">终止语句</h3>

<p>
	<i>终止语句</i> 阻止了同一个<a href="#Blocks">块</a>中在其后（词法上）出现的语句的执行。
	以下语句是终结的：
</p>

<ol>
<li>
	<a href="#Return_statements">"return"</a> 或者 <a href="#Goto_statements">"goto"</a> 语句。
	<!-- ul below only for regular layout -->
	<ul> </ul>
</li>

<li>
	对内置函数 <a href="#Handling_panics"><code>panic</code></a> 的调用。
	<!-- ul below only for regular layout -->
	<ul> </ul>
</li>

<li>
	语句列表以终止语句结束的<a href="#Blocks">块</a>。
	<!-- ul below only for regular layout -->
	<ul> </ul>
</li>

<li>
	满足如下条件的 <a href="#If_statements">"if" 语句</a>：
	<ul>
	<li>"else" 分支存在</li>
	<li>两个分支都是终止语句。</li>
	</ul>
</li>

<li>
	满足如下的 <a href="#For_statements">"for" 语句</a>：
	<ul>
	<li>没有针对这个 "for" 语句的 "break" 语句</li>
	<li>循环条件为空。</li>
	</ul>
</li>

<li>
	满足如下的 <a href="#Switch_statements">"switch" 语句</a>：
	<ul>
	<li>没有针对这个 "switch" 语句的 "break" 语句</li>
	<li>有一个 default case</li>
	<li>在每个 case 中（包括默认的）的语句列表以终止语句或者一个可能标记为 <a href="#Fallthrough_statements">"fallthrough" 的语句</a>结束。</li>
	</ul>
</li>

<li>
	满足如下的 <a href="#Select_statements">"select" 语句</a>：
	<ul>
	<li>没有针对这个 "select" 语句的 "break" 语句</li>
	<li>在每个 case 中（包括默认的）的语句列表是存在的并以终止语句结束。</li>
	</ul>
</li>

<li>
	标记终止语句的<a href="#Labeled_statements">标签语句</a>。
</li>
</ol>

<p>
	所有其它语句都不是终止的。
</p>

<p>
	如果语句列表非空且其最后的非空语句是终止的，那么这个<a href="#Blocks">语句列表</a>以终结语句结束。
</p>


<h3 id="Empty_statements">空语句</h3>

<p>
	空语句什么都不做。
</p>

<pre class="ebnf">
EmptyStmt = .
</pre>


<h3 id="Labeled_statements">标签语句</h3>

<p>
	标签语句可以是 <code>goto</code>，<code>break</code> 或 <code>continue</code> 语句的目标。
</p>

<pre class="ebnf">
LabeledStmt = Label ":" Statement .
Label       = identifier .
</pre>

<pre>
Error: log.Panic("error encountered")
</pre>


<h3 id="Expression_statements">表达式语句</h3>

<p>
	除了特定的内置函数外，函数和方法<a href="#Calls">调用</a>以及<a href="#Receive_operator">接收操作</a>可以出现在语句上下文中。
	这种语句可能会被括起来。
</p>

<pre class="ebnf">
ExpressionStmt = Expression .
</pre>

<p>
	下述内置函数不允许出现在语句上下文中：
</p>

<pre>
append cap complex imag len make new real
unsafe.Alignof unsafe.Offsetof unsafe.Sizeof
</pre>

<pre>
h(x+y)
f.Close()
&lt;-ch
(&lt;-ch)
len("foo")  // 如果 len 是内置函数，那么是非法的
</pre>


<h3 id="Send_statements">发送语句</h3>

<p>
	发送语句在 channel 上发送一个值。
	channel 表达式必须是<a href="#Channel_types">channel 类型</a>，channel 方向必须允许发送操作，并且，发送值的类型必须<a href="#Assignability">可分配</a>为 channel 的元素类型。
</p>

<pre class="ebnf">
SendStmt = Channel "&lt;-" Expression .
Channel  = Expression .
</pre>

<p>
	channel 和值表达式都会在通讯开始前执行。直到发送进行前，通讯都是阻塞的。
	如果接收者准备好了那么在无缓冲的 channel 上的发送就可以进行了。
	如果缓冲区还有空间那么在带缓冲的 channel 上的发送就可以进行。
	在关闭的 channel 上进行发送会产生一个 <a href="#Run_time_panics">run-time panic</a>。
	在值为 <code>nil</code> 的 channel 上的发送是会永久阻塞的。
</p>

<pre>
ch &lt;- 3  // 发送值 3 到信道 ch
</pre>


<h3 id="IncDec_statements">自增或自减语句</h3>

<p>
	"++" 和 "--" 语句用无类型<a href="#Constants">常量</a> <code>1</code> 来增加或减少其操作数。
	和赋值一样，这个操作数必须是<a href="#Address_operators">可被寻址的</a>或者是一个映射索引表达式。
</p>

<pre class="ebnf">
IncDecStmt = Expression ( "++" | "--" ) .
</pre>

<p>
	以下<a href="#Assignments">赋值语句</a>在语义上是等同的：
</p>

<pre class="grammar">
自增或自减语句　   		 赋值
x++                 x += 1
x--                 x -= 1
</pre>


<h3 id="Assignments">赋值</h3>

<pre class="ebnf">
Assignment = ExpressionList assign_op ExpressionList .

assign_op = [ add_op | mul_op ] "=" .
</pre>

<p>
	每个左侧的操作数必须是<a href="#Address_operators">可被寻址的</a>、一个映射索引表达式或（只对 <code>=</code> 赋值来说）<a href="#Blank_identifier">空白标识符</a>。
	操作数可能会被括起来。
</p>

<pre>
x = 1
*p = f()
a[i] = 23
(k) = &lt;-ch  // 同： k = &lt;-ch
</pre>

<p>
	当 <i>op</i> 是一个二元<a href="#Arithmetic_operators">算数运算符</a>时，<i>赋值操作</i> <code>x</code> <i>op</i><code>=</code> <code>y</code> 等同于 <code>x</code> <code>=</code> <code>x</code> <i>op</i> <code>(y)</code>，不过 <code>x</code> 仅求值一次。
	<i>op</i><code>=</code> 构造是一个单独的记号。
	在赋值操作中，左侧和右侧的表达式列表都必须含有一个确切的单一值表达式，并且左侧的表达式不能为空白标识符。
</p>

<pre>
a[i] &lt;&lt;= 2
i &amp;^= 1&lt;&lt;n
</pre>

<p>
	多元赋值分配多值运算的独立的值到一个变量列表。
	有两种形式。
	第一种，右侧的操作数是譬如函数调用、<a href="#Channel_types">channel</a>、<a href="#Map_types">map</a> 运算、<a href="#Type_assertions">类型断言</a>这样的单个多值表达式。
	左侧的操作数的个数必须和值的个数匹配。比如，如果 <code>f</code> 是一个返回两个值的函数，
</p>

<pre>
x, y = f()
</pre>

<p>
	分配第一个值给 <code>x</code> 第二个给 code>y</code>。
	第二种形式，左侧操作数的个数必须等于右侧表达式的个数，每个表达式必须是单一的值，并且右侧第 <i>n</i> 个表达式会分配给左侧第 <i>n</i> 个操作数：
</p>

<pre>
one, two, three = '一', '二', '三'
</pre>

<p>
	在赋值中，<a href="#Blank_identifier">空白标识符</a>提供了一个忽略右侧值的方法：
</p>

<pre>
_ = x       // 对 x 求值，但是会忽略它
x, _ = f()  // 对 f() 求值，但是忽略了它的第二个结果值
</pre>

<p>
	赋值会分两个阶段进行。
	第一阶段，左侧的<a href="#Index_expressions">索引表达式</a>和<a href="#Address_operators">指针间接</a>（包括在<a href="#Selectors">选择器</a>中的隐式的指针间接）以及右侧的表达式都会按照<a href="#Order_of_evaluation">通常的顺序来求值</a>。
	第二阶段，赋值按从左至右的顺序进行。
</p>

<pre>
a, b = b, a  // 交换 a 和 b

x := []int{1, 2, 3}
i := 0
i, x[i] = 1, 2  // 设 i = 1, x[0] = 2

i = 0
x[i], i = 2, 1  // 设 x[0] = 2, i = 1

x[0], x[0] = 1, 2  // 先设 x[0] = 1, 然后 x[0] = 2 （所以最后 x[0] == 2）

x[1], x[3] = 4, 5  // 设 x[1] = 4, 然后设 x[3] = 5

type Point struct { x, y int }
var p *Point
x[2], p.x = 6, 7  // 设 x[2] = 6, 然后设 p.x = 7

i = 2
x = []int{3, 5, 7}
for i, x[i] = range x {  // 设 i, x[2] = 0, x[0]
	break
}
// 循环结束后， i == 0 且 x == []int{3, 5, 3}
</pre>

<p>
	在赋值中，每个值都必须是<a href="#Assignability">可分配</a>给需要分配的操作数的类型的，不过会有以下特殊情况：
</p>

<ol>
<li>
	任何类型的值都可以被分配给空白标识符。
</li>

<li>
	当无类型常量被分配给一个接口类型变量或是空白标识符时，常量会先被隐式地<a href="#Conversions">转换</a>为它的<a href="#Constants">默认类型</a>。
</li>

<li>
	当无类型布尔值被分配给一个接口类型变量或是空白标识符时，它会先被隐式地转换为<code>布尔类型</code>。
</li>
</ol>

<h3 id="If_statements">If 语句</h3>

<p>
	"if" 语句根据布尔表达式的值来指定两个分支的条件执行。
	当表达式求值得真时， "if" 分支被执行，否则执行 "else" 分支（存在的话）。
</p>

<pre class="ebnf">
IfStmt = "if" [ SimpleStmt ";" ] Expression Block [ "else" ( IfStmt | Block ) ] .
</pre>

<pre>
if x &gt; max {
	x = max
}
</pre>

<p>
	表达式前面可能会有一个简单的语句，这个语句会在表达式求值之前被执行。
</p>

<pre>
if x := f(); x &lt; y {
	return x
} else if x &gt; z {
	return z
} else {
	return y
}
</pre>


<h3 id="Switch_statements">Switch 语句</h3>

<p>
	"switch" 语句提供了多路执行。
	表达式或者类型指示符会和在 "switch" 内的 "case" 做比较去确定执行哪一个分支。
</p>

<pre class="ebnf">
SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
</pre>

<p>
	有两种形式：表达式开关（switch）和类型开关。
	在表达式开关中，case 包含了要与 switch 表达式的值比较的表达式。
	在类型开关中，case 包含了要与特别说明的 switch 表达式的类型比较的类型。
	switch 表达式在一个开关语句中仅求值一次。
</p>

<h4 id="Expression_switches">表达式开关</h4>

<p>
	在表达式开关中，switch 表达式和 case 表达式（不能是常量）是按照从左至右、从上之下的顺序进行求值的；第一个和 switch 表达式相等的 case 中对应的语句会被触发执行；其它 case 会被跳过。
	如果没有 case 匹配且有一个 "default" case，那么会执行这个 case 的语句。
	最多有一个默认 case ，它可以出现在 "switch" 语句的任意位置。
	当 switch 表达式不存在时，相当于是一个布尔值 <code>true</code>。
</p>

<pre class="ebnf">
ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" .
ExprCaseClause = ExprSwitchCase ":" StatementList .
ExprSwitchCase = "case" ExpressionList | "default" .
</pre>

<p>
	如果 switch 表达式求值为一个无类型常量，它会先被隐式地<a href="#Conversions">转换</a>为它的<a href="#Constants">默认类型</a>；如果它是一个无类型的布尔值，它会先被隐式地转换为类型 <code>bool</code>。
	预定义的无类型值 <code>nil</code> 不能用在 switch 表达式中。
</p>

<p>
	如果 case 表达式是无类型的，那么它会先被隐式地<a href="#Conversions">转换</a>为 switch 表达式的类型。
	对于每个（可能是转换过的） case <a href="#Comparison_operators">表达式</a> <code>x</code> 和 switch 表达式的值 <code>t</code>，<code>x == t</code> 必定是一个有效的<a href="#Comparison_operators">比较</a>。
</p>

<p>
	也就是说， switch 表达式就像是被用来声明和初始化一个没有明确类型的临时变量 <code>t</code>；为了测试相等性，这个临时变量 <code>t</code> 的值会和每一个 case 表达式 <code>x</code> 做判断。
</p>

<p>
	在一个 case 或 default 子句中，最后的非空语句可能是一个（可能是<a href="#Labeled_statements">标签</a>的）<a href="#Fallthrough_statements">"fallthrough" 语句</a>用来指示控制应该从本子句流出以流入下个子句的第一个语句。
	不然的话控制会流到 "switch" 语句的末尾。
	"fallthrough" 语句可以作为除了表达式开关的最后一个子句外的其它所有子句的最后一条语句出现。
</p>

<p>
	switch 表达式可以前缀一个简单的语句，这个语句会在表达式之前执行。
</p>

<pre>
switch tag {
default: s3()
case 0, 1, 2, 3: s1()
case 4, 5, 6, 7: s2()
}

switch x := f(); {  // 缺少 switch 表达式就意味着 "true"
case x &lt; 0: return -x
default: return x
}

switch {
case x &lt; y: f1()
case x &lt; z: f2()
case x == 4: f3()
}
</pre>

<p>
	实现限制：编译器可能会不允许多个 case 表达式求值结果为相同的常量。
	例如，现在的编译器不允许重复的整数、浮点数或字符串常量出现在 case 表达式中。
</p>

<h4 id="Type_switches">类型开关</h4>

<p>
	类型开关用于比较类型而不是值。
	其它方面和表达式开关类似。
	它的标识是一个特殊的 switch 表达式，这个表达式形式是一个使用了保留字 <code>type</code> 而不是一个实际类型的<a href="#Type_assertions">类型断言</a>。
</p>

<pre>
switch x.(type) {
// cases
}
</pre>

<p>
	然后 case 匹配实际的类型 <code>T</code> 而不是表达式 <code>x</code> 的动态类型。
	与类型断言一样，<code>x</code> 必须是<a href="#Interface_types">接口类型</a>，并且在 case 中的每一个非接口类型 <code>T</code> 必须实现 <code>x</code> 的类型。
	在类型开关的 case 中的类型必须都是<a href="#Type_identity">不同的</a>。
</p>

<pre class="ebnf">
TypeSwitchStmt  = "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}" .
TypeSwitchGuard = [ identifier ":=" ] PrimaryExpr "." "(" "type" ")" .
TypeCaseClause  = TypeSwitchCase ":" StatementList .
TypeSwitchCase  = "case" TypeList | "default" .
TypeList        = Type { "," Type } .
</pre>

<p>
	TypeSwitchGuard 可能会包含一个<a href="#Short_variable_declarations">短变量声明</a>。
	当用了这种形式的话，变量会在每个子句的 TypeSwitchCase 末尾的<a href="#Blocks">隐式块</a>中被声明。
	在只列出一个类型的 case 的子句中，变量类型就是这个类型；否则，变量类型为 TypeSwitchGuard 中表达式的类型。
</p>

<p>
	不同于类型， case 可以使用预声明的标识符 <a href="#Predeclared_identifiers"><code>nil</code></a>；这种会在 TypeSwitchGuard 中的表达式为 <code>nil</code> 接口值时被选择。
	只能最多一个 <code>nil</code> case。
</p>

<p>
	给定一个 <code>interface{}</code> 类型的表达式 <code>x</code>，以下类型开关：
</p>

<pre>
switch i := x.(type) {
case nil:
	printString("x is nil")                // i 类型为 x 的类型（interface{}）
case int:
	printInt(i)                            // i 类型为 int
case float64:
	printFloat64(i)                        // i 类型为 float64
case func(int) float64:
	printFunction(i)                       // i 类型为 func(int) float64
case bool, string:
	printString("type is bool or string")  // i 类型为 x 的类型（interface{}）
default:
	printString("don't know the type")     // i 类型为 x 的类型（interface{}）
}
</pre>

<p>
	可以被重写为：
</p>

<pre>
v := x  // x 只执行一次
if v == nil {
	i := v                                 // i 类型为 x 的类型（interface{}）
	printString("x is nil")
} else if i, isInt := v.(int); isInt {
	printInt(i)                            // i 类型为 int
} else if i, isFloat64 := v.(float64); isFloat64 {
	printFloat64(i)                        // i 类型为 float64
} else if i, isFunc := v.(func(int) float64); isFunc {
	printFunction(i)                       // i 类型为 func(int) float64
} else {
	_, isBool := v.(bool)
	_, isString := v.(string)
	if isBool || isString {
		i := v                         // i 类型为 x 的类型（interface{}）
		printString("type is bool or string")
	} else {
		i := v                         // i 类型为 x 的类型（interface{}）
		printString("don't know the type")
	}
}
</pre>

<p>
	TypeSwitchGuard 可以前缀一个简单的语句，这个语句在 guard 之前执行。
</p>

<p>
	"fallthrough" 语句在类型开关中是不被允许的。
</p>

<h3 id="For_statements">For 语句</h3>

<p>
	"for" 语句规定了一个块的重复执行。
	有三种形式：迭代可以被一个单一条件、一个 "for" 子句或是一个 "range" 子句控制。
</p>

<pre class="ebnf">
ForStmt = "for" [ Condition | ForClause | RangeClause ] Block .
Condition = Expression .
</pre>

<h4 id="For_condition">带单一条件的 for 语句</h4>

<p>
	在它最简单的形式中， "for" 语句就像一个求值为真的布尔条件一样来规定一个块的重复执行。
	这个条件的值会在每次迭代前都被求一下。如果条件为空，那么就相当于布尔值 <code>true</code>。
</p>

<pre>
for a &lt; b {
	a *= 2
}
</pre>

<h4 id="For_clause">带 <code>for</code> 子句的 For 语句</h4>

<p>
	带一个 ForClause 的 "for" 子句也是通过其条件来控制的，但是它会额外指定一个 <i>init</i> 和 <i>post</i> 语句，比如一个赋值、增量或减量语句。
	Init 语句可以是一个<a href="#Short_variable_declarations">短变量声明</a>，但 post 语句一定不是。
	通过 init 语句声明的变量会在每次迭代时被重复使用。
</p>

<pre class="ebnf">
ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .
InitStmt = SimpleStmt .
PostStmt = SimpleStmt .
</pre>

<pre>
for i := 0; i &lt; 10; i++ {
	f(i)
}
</pre>

<p>
	如果非空，init 语句会在首次迭代的条件求值前被执行一次；post 语句会在每次块执行完后被执行（并且只有在块有执行过后）。
	ForClause 每个元素都可以是空的，但是<a href="#Semicolons">分号</a>是必须要有的，除非仅存在一个条件元素。
	如果条件为空，那么就相当于布尔值 <code>true</code>。
</p>

<pre>
for cond { S() }    同    for ; cond ; { S() }
for      { S() }    同    for true     { S() }
</pre>

<h4 id="For_range">带 <code>range</code> 子句的 For 语句</h4>

<p>
	带 "range" 子句的 "for" 语句会彻底地迭代数组、切片、字符串或 map 的所有条目，或是从 channel 接收到的值。
	针对每一个条目，它在分配<i>迭代值</i> 给对应且存在的<i>迭代变量</i> 后再执行语句块。
</p>

<pre class="ebnf">
RangeClause = [ ExpressionList "=" | IdentifierList ":=" ] "range" Expression .
</pre>

<p>
	"range" 子句中右侧的表达式被称为<i>范围表达式</i>，它可以是数组、到数组的指针、切片、字符串、map 或是允许<a href="#Receive_operator">接收操作</a>的 channel。
	和赋值一样，如果左侧操作数存在，那么它一定是<a href="#Address_operators">可被寻址的</a>或 map 索引表达式；它们表示为迭代变量。
	如果范围表达式是一个信道，那么最多允许一个迭代变量，其它情况下可以最多到两个。
	如果最后的迭代变量是<a href="#Blank_identifier">空白标识符</a>，那么这个 range 子句和没有这个标识符的子句是相同的。
</p>

<p>
	范围表达式 <code>x</code> 会在开始此循环前被执行一次，但有一个例外：当存在最多一个迭代变量且 <code>len(x)</code> 是<a href="#Length_and_capacity">常量</a>时，范围表达式是不被执行的。
</p>

<p>
	左侧的函数调用在每次迭代时被执行。
	对于每个迭代，如果迭代变量存在，那么对应的迭代值是按以下说明产生的：
</p>

<pre class="grammar">
范围表达式                          			第一个值　　         第二个值

array or slice  a  [n]E, *[n]E, or []E    index    i  int    a[i]       E
string          s  string type            index    i  int    see below  rune
map             m  map[K]V                key      k  K      m[k]       V
channel         c  chan E, &lt;-chan E       element  e  E
</pre>

<ol>
<li>
	对于数组、到数组的指针或是切片值 <code>a</code>，其索引迭代值是从索引 0 开始，以递增次序产生的。
	如果存在最多一个迭代变量， range 循环会创建从 0 到 <code>len(a)-1</code> 的迭代值，且不会索引进数组或切片内。
	对于 <code>nil</code> 切片而言，迭代数是 0。
</li>

<li>
	对于字符串值，"range" 子句从字节索引 0 开始迭代字符串中的 Unicode 码位。
	在连续的迭代上，索引值是字符串中连续 UTF-8 编码的码位的第一个字节的索引，而第二个值（类型是 <code>rune</code>）是对应的码位的值。
	如果迭代遇到了无效的 UTF-8 序列，那么第二个值会变成 Unicode 替换字符 <code>0xFFFD</code>，且下一个迭代将在字符串中前进一个字节。
</li>

<li>
	map 的迭代顺序是未指定的，并且不能保证两次完整的迭代是相同的。
	如果在迭代中某个未接触到的 map 条目被移除了，那么对应的迭代值就不会产生。
	如果在迭代中新创建了一个 map 条目，那这个条目可能会在迭代中被产生也可能被跳过。
	对于每个条目的创建或是一个迭代到下一个迭代，选择可能很多样。
	如果 map 是 <code>nil</code>，迭代数为 0。
</li>

<li>
	对于 channels，迭代值是在信道上发送的直到 channel <a href="#Close">关闭</a>的连续值。
	如果信道是 <code>nil</code>，那么范围表达式会永久阻塞。
</li>
</ol>

<p>
	迭代值会像<a href="#Assignments">赋值语句</a>一样被赋值给对应的迭代变量。
</p>

<p>
	迭代变量可以被 "range" 子句使用<a href="#Short_variable_declarations">短变量声明</a>（<code>:=</code>）的形式声明。
	这种情况下，它们的类型会被设置为对应迭代值的类型，且它们的<a href="#Declarations_and_scope">作用域</a>是 "for" 语句块；这些变量会在每次迭代时复用。
	如果迭代变量是在 "for" 语句外被声明的，那么在执行完毕后，它们的值会是最后一次迭代的值。
</p>

<pre>
var testdata *struct {
	a *[7]int
}
for i, _ := range testdata.a {
	// testdata.a 不会被求值; len(testdata.a) 是常量
	// i 范围从 0 到 6
	f(i)
}

var a [10]string
for i, s := range a {
	// i 类型为 int
  	// s 类型为 string
	// s == a[i]
	g(i, s)
}

var key string
var val interface{}  // m 的元素类型可赋予 val
m := map[string]int{"mon":0, "tue":1, "wed":2, "thu":3, "fri":4, "sat":5, "sun":6}
for key, val = range m {
	h(key, val)
}
// key == 迭代中遇到的最后一个 map 键
// val == map[key]

var ch chan Work = producer()
for w := range ch {
	doWork(w)
}

// 空 channel
for range ch {}
</pre>


<h3 id="Go_statements">Go 语句</h3>

<p>
	"go" 语句在同一地址空间内以独立的并发控制线程或 <i>goroutine</i> 的形式开始执行函数调用。
</p>

<pre class="ebnf">
GoStmt = "go" Expression .
</pre>

<p>
	表达式必须是函数或方法调用；它不能是括起来的。
	对内置函数的调用会有和<a href="#Expression_statements">表达式语句</a>一样的限制。
</p>

<p>
	在调用的 goroutine 中的函数值和参数是按<a href="#Calls">通常的情况来执行</a>的，但不同于普通调用的是，程序执行不会等待被调用的函数执行完毕。
	相反，在新的 goroutine 中的函数是独立执行的。
	当函数终止，其 goroutine 也会终止。
	如果函数存在任何返回值，这些值会在函数完成时被丢弃。
</p>

<pre>
go Server()
go func(ch chan&lt;- bool) { for { sleep(10); ch &lt;- true }} (c)
</pre>


<h3 id="Select_statements">Select 语句</h3>

<p>
	"select" 语句会选择一组或是<a href="#Send_statements">发送</a>或是<a href="#Receive_operator">接收</a>的操作来进行。
	它看起来和 <a href="#Switch_statements">"switch"</a> 语句类似，但它所有的 case 只涉及通讯操作。
</p>

<pre class="ebnf">
SelectStmt = "select" "{" { CommClause } "}" .
CommClause = CommCase ":" StatementList .
CommCase   = "case" ( SendStmt | RecvStmt ) | "default" .
RecvStmt   = [ ExpressionList "=" | IdentifierList ":=" ] RecvExpr .
RecvExpr   = Expression .
</pre>

<p>
	带 RecvStmt 的 case 可能会分配 RecvExpr 的结果到一个或两个变量，变量是用<a href="#Short_variable_declarations">短变量声明</a>声明的。
	RecvExpr 一定是一个（可能是括起来的）接收操作。
	最多可以有一个默认 case，它可以出现在 case 列表的任意位置。
</p>

<p>
	"select" 语句的执行按如下几个步骤进行：
</p>

<ol>
<li>
	对于语句中的所有 case 来说，其接收操作和 channel 的 channel 操作数以及发送语句右侧的表达式会在进入 "select" 语句时以源码的顺序被执行仅一次。
	结果是需要接收或发送的 channel 集，以及对应的需要发送的值。
	无论选择哪个（如果有）通讯操作进行，在这个求值中的任何副作用都会发生。
	RecvStmt 左侧的带短变量声明或赋值的表达式还不会被求值。
</li>

<li>
	如果可以发生一个或多个通讯，通过统一的伪随机选择确定一个来进行。
	否则，如果有一个默认的 case，那么这个 case 会被选择。
	如果没有默认的 case，那么这个 "select" 语句会阻塞，直到至少发生了一个通讯。
</li>

<li>
	除非被选择的 case 是默认的 case，否则各自的通讯操作会被执行。
</li>

<li>
	如果被选择的 case 是一个带短变量声明或赋值的 RecvStmt，那么左侧的表达式会被求值且接收到的值会被分配。
</li>

<li>
	执行所选择的 case 的语句列表。
</li>
</ol>

<p>
	由于在 <code>nil</code> channels 上的通讯永不会进行，所以只带 <code>nil</code> channels 且没有默认 case 的 select 会永久阻塞。
</p>

<pre>
var a []int
var c, c1, c2, c3, c4 chan int
var i1, i2 int
select {
case i1 = &lt;-c1:
	print("received ", i1, " from c1\n")
case c2 &lt;- i2:
	print("sent ", i2, " to c2\n")
case i3, ok := (&lt;-c3):  // 同： i3, ok := &lt;-c3
	if ok {
		print("received ", i3, " from c3\n")
	} else {
		print("c3 is closed\n")
	}
case a[f()] = &lt;-c4:
	// 同：
	// case t := &lt;-c4
	//	a[f()] = t
default:
	print("no communication\n")
}

for {  // 发送（伪）随机比特序列到 c
	select {
	case c &lt;- 0:  // n注意：没有语句，没有 fallthrough，没有可折叠的 case
	case c &lt;- 1:
	}
}

select {}  // 永久阻塞
</pre>


<h3 id="Return_statements">Return 语句</h3>

<p>
	函数 <code>F</code> 中的 "return" 语句会终止 <code>F</code> 的执行，并可选择地提供一个或更多的返回值。
	任何被 <code>F</code> <a href="#Defer_statements">推迟</a>的函数会在 <code>F</code> 返回到它调用者前被执行。
</p>

<pre class="ebnf">
ReturnStmt = "return" [ ExpressionList ] .
</pre>

<p>
	在没有结果类型的函数中，"return" 语句一定不指定任何返回值。
</p>
<pre>
func noResult() {
	return
}
</pre>

<p>
	带有结果类型的函数有三种返回值：
</p>

<ol>
	<li>一个或多个返回值可以在 "return" 语句中明确列出
		每个表达式一定是单一值的且是<a href="#Assignability">可分配</a>给对应的函数返回类型的元素。
<pre>
func simpleF() int {
	return 2
}

func complexF1() (re float64, im float64) {
	return -7.0, -4.0
}
</pre>
	</li>
	<li>在 "return" 语句中的表达式列表可以是对多值函数的单一调用。
		效果就犹如从这个函数返回的值被分配给带对应值类型的一个临时变量，然后这些变量会跟随在 "return" 语句后，并适用上述情况指明的规则。
<pre>
func complexF2() (re float64, im float64) {
	return complexF1()
}
</pre>
	</li>
	<li>如果函数结果值对其<a href="#Function_types">结果参数</a>规定了名字，那么表达式列表可以为空。
		结果参数会作为本地变量，函数也可以在需要时给它们赋值。
		"return" 语句会返回这些变量的值。
<pre>
func complexF3() (re float64, im float64) {
	re = 7.0
	im = 4.0
	return
}

func (devnull) Write(p []byte) (n int, _ error) {
	n = len(p)
	return
}
</pre>
	</li>
</ol>

<p>
	不管它们是如何声明的，在进入函数时，所有结果值都会被初始化为其类型的<a href="#The_zero_value">零值</a>。
	指定结果的 "return" 语句会在任何推迟函数执行前设置结果参数。
</p>

<p>
	实现限制：当一个和结果参数同名的实体（常量、类型或变量）在 return 位置的<a href="#Declarations_and_scope">作用域</a>内时，编译器会不允许空的表达式列表出现在 "return" 语句中。
</p>

<pre>
func f(n int) (res int, err error) {
	if _, err := f(n-1); err != nil {
		return  // 无效的返回语句：err 被遮蔽了
	}
	return
}
</pre>

<h3 id="Break_statements">Break 语句</h3>

<p>
	"break" 语句终止在相同函数内最内层的 <a href="#For_statements">"for"</a>，<a href="#Switch_statements">"switch"</a> 或 <a href="#Select_statements">"select"</a> 语句的执行。
</p>

<pre class="ebnf">
BreakStmt = "break" [ Label ] .
</pre>

<p>
	如果这里有一个标签，那它必须是一个封闭的 "for"、"switch" 或 "select" 语句，然后这个标签终止执行上面三个语句。
</p>

<pre>
OuterLoop:
	for i = 0; i &lt; n; i++ {
		for j = 0; j &lt; m; j++ {
			switch a[i][j] {
			case nil:
				state = Error
				break OuterLoop
			case item:
				state = Found
				break OuterLoop
			}
		}
	}
</pre>

<h3 id="Continue_statements">Continue 语句</h3>

<p>
	"continue" 语句在发布位置开始执行最内层 "<a href="#For_statements">"for"  循环</a>的下一次迭代。
	"for" 循环必须在同一个函数内。
</p>

<pre class="ebnf">
ContinueStmt = "continue" [ Label ] .
</pre>

<p>
	如果有一个标签，则必须是一个封闭的 "for" 语句的标签，并且该标签将继续执行。
</p>

<pre>
RowLoop:
	for y, row := range rows {
		for x, data := range row {
			if data == endOfRow {
				continue RowLoop
			}
			row[x] = data + bias(x, y)
		}
	}
</pre>

<h3 id="Goto_statements">Goto 语句</h3>

<p>
	"goto" 语句将控制权转移到同一函数中带有相应标签的语句。
</p>

<pre class="ebnf">
GotoStmt = "goto" Label .
</pre>

<pre>
goto Error
</pre>

<p>
	执行 "goto" 语句一定不能使任何在 goto 时还没有在<a href="#Declarations_and_scope">作用域</a>中的变量进入作用域中。
	例如，这个例子：
</p>

<pre>
	goto L  // 坏的
	v := 3
L:
</pre>

<p>
	是错误的，因为跳转到标签 <code>L</code> 会眺过 <code>v</code> 的创建。
</p>

<p>
	在某个<a href="#Blocks">块</a>外的 "goto" 语句不能跳转到这个块内。
	例如，这个例子：
</p>

<pre>
if n%2 == 1 {
	goto L1
}
for n &gt; 0 {
	f()
	n--
L1:
	f()
	n--
}
</pre>

<p>
	是错误的，因为标签 <code>L1</code> 在 "for" 语句块内，但是 <code>goto</code> 不在。
</p>

<h3 id="Fallthrough_statements">Fallthrough 语句</h3>

<p>
	"fallthrough" 语句转移控制给<a href="#Expression_switches">表达式 "switch" 语句</a>内下一个 case 子句的第一条语句。
	它仅作为此类子句的最终非空语句使用。
</p>

<pre class="ebnf">
FallthroughStmt = "fallthrough" .
</pre>


<h3 id="Defer_statements">Defer 语句</h3>

<p>
	"defer" 语句调用一个函数，该函数的执行被推迟到周围函数返回的那一刻，这是因为周围函数执行了一条<a href="#Return_statements">return 语句</a>，到达了<a href="#Function_declarations">函数体</a>的末尾，或者是因为相应的goroutine <a href="#Handling_panics">panicking</a> 了。
</p>

<pre class="ebnf">
DeferStmt = "defer" Expression .
</pre>

<p>
	这个表达式一定是一个函数或者方法调用；它不能是括起来的。
	对内置函数的调用会如<a href="#Expression_statements">表达式语句</a>一样被限制。
</p>

<p>
	每次 "defer" 语句执行时，针对调用的函数值和参数是按<a href="#Calls">通常的情况来执行</a>并重新保存的，但实际的函数是不调用的。
	相反，被推迟的函数会在其环绕函数返回前，按照被推迟的反序被瞬间调用。
	也就是说，如果围绕函数通过一个明确的<a href="#Return_statements">return 语句</a>返回的话，那么被推迟的函数会在所有被 return 语句所设置的结果参数<i>后</i>，在函数返回到其调用者<i>前</i> 被执行。
	如果推迟函数求值得 <code>nil</code>，那么在函数被调用时（而不是在 "defer" 语句被执行时），执行会 <a href="#Handling_panics">panics</a>。
</p>

<p>
	例如，如果被推迟的函数是一个<a href="#Function_literals">函数字面量</a>并且其环绕函数有在该字面量作用域内的<a href="#Function_types">命名的结果参数</a>，那么该被推迟的函数可以在那些结果参数被返回前访问并修改它们。
	如果被推迟的函数有任何返回值，这些值会在函数完成时被丢弃。（也看一下<a href="#Handling_panics">处理恐慌</a>一节）
</p>

<pre>
lock(l)
defer unlock(l)  // 解锁发生在环绕函数返回前

// 在环绕函数返回前打印 3 2 1 0
for i := 0; i &lt;= 3; i++ {
	defer fmt.Print(i)
}

// f 会返回 42
func f() (result int) {
	defer func() {
		// 结果会在其被 return 语句设为 6 之后再被访问
		result *= 7
	}()
	return 6
}
</pre>

<h2 id="Built-in_functions">内置函数</h2>

<p>
	内置函数是<a href="#Predeclared_identifiers">预先声明</a>的。
	它们和其它任何函数一样调用，但是其中有一些能接受类型而不是表达式作为其第一个实参。
</p>

<p>
	内置函数没有标准的 Go 类型，所以它们只能出现在<a href="#Calls">调用表达式</a>中；它们不能作为函数值来使用。
</p>

<h3 id="Close">Close</h3>

<p>
	对于 channel <code>c</code>，内置函数 <code>close(c)</code> 标明了将不会再有值被发送到这个 channel。
	如果 <code>c</code> 是一个仅可接收的 channel，那么会出错。发送到或者关闭一个已经关闭的 channel 会发生 <a href="#Run_time_panics">run-time panic</a>。
	关闭 nil channel 也会发生 <a href="#Run_time_panics">run-time panic</a>。
	调用 <code>close</code> 后，以及任何之前被发送的值都被接收后，接收操作不会阻塞而将是会返回对应 channel 类型的零值。
	多值<a href="#Receive_operator">接收操作</a>会返回一个接收到的值，随同一个 channel 是否已经被关闭的指示符。
</p>


<h3 id="Length_and_capacity">长度和容量</h3>

<p>
	内置函数 <code>len</code> 和 <code>cap</code> 获取各种类型的实参并返回一个 <code>int</code> 类型结果。
	实现会保证结果总是一个 <code>int</code> 值。
</p>

<pre class="grammar">
调用       实参类型    		结果

len(s)    string type      按字节表示的字符串长度
          [n]T, *[n]T      数组长度（== n）
          []T              切片长度
          map[K]T          map 长度（定义的键的个数）
          chan T           在 channel 缓冲区内排队的元素个数

cap(s)    [n]T, *[n]T      数组长度（== n）
          []T              切片容量
          chan T           channel 缓冲区容量
</pre>

<p>
	切片的容量是为其底层数组所分配的空间所对应的元素个数。
	任何时间都满足如下关系：
</p>

<pre>
0 &lt;= len(s) &lt;= cap(s)
</pre>

<p>
	<code>nil</code> 切片、map 或者 channel 的长度是 0。
	<code>nil</code> 切片或 channel 的容量是 0。
</p>

<p>
	如果 <code>s</code> 是一个字符串常量，那么 <code>len(s)</code> 是一个<a href="#Constants">常量</a>。
	如果 <code>s</code> 类型是一个数组或到数组的指针且表达式 <code>s</code> 不包含<a href="#Receive_operator">channel 接收</a>或（非常量的）<a href="#Calls">函数调用</a>的话，那么表达式 <code>len(s)</code> 和 <code>cap(s)</code> 是常量；这种情况下，<code>s</code> 是不执行的。
	否则的话，<code>len</code> 和 <code>cap</code> 的调用不是常量且 <code>s</code> 会被执行。
</p>

<pre>
const (
	c1 = imag(2i)                    // imag(2i) = 2.0 是一个常量
	c2 = len([10]float64{2})         // [10]float64{2} 不包含函数调用
	c3 = len([10]float64{c1})        // [10]float64{c1} 不包含函数调用
	c4 = len([10]float64{imag(2i)})  // imag(2i) 是一个常量且没有函数调用
	c5 = len([10]float64{imag(z)})   // 无效的: imag(z) 是一个非常量的函数调用
)
var z complex128
</pre>

<h3 id="Allocation">分配</h3>

<p>
	内置函数 <code>new</code> 获取一个类型 <code>T</code>，在运行时为该类型的<a href="#Variables">变量</a>分配地址空间，并返回一个<a href="#Pointer_types">指向</a>它的类型为 <code>*T</code> 的值。
	这个变量会按照<a href="#The_zero_value">初始化值</a>一节所描述的来初始化。
</p>

<pre class="grammar">
new(T)
</pre>

<p>
	例如：
</p>

<pre>
type S struct { a int; b float64 }
new(S)
</pre>

<p>
	为 <code>S</code> 类型变量分配存储空间，初始化它（<code>a=0</code>，<code>b=0.0</code>），然后返回含有位置地址的类型为 <code>*S</code> 的一个值。
</p>

<h3 id="Making_slices_maps_and_channels">创建切片, maps and channels</h3>

<p>
	内置函数 make 获取一个切片、map 或 channel 类型 <code>T</code>，可选择性的接一个类型相关的表达式列表。
	它会返回类型 <code>T</code> 的值（不是 <code>*T</code>）。
	内存会按照<a href="#The_zero_value">初始化值</a>一节所描述的来初始化。
</p>

<pre class="grammar">
调用              类型 T     	结果

make(T, n)       分片      	带 n 长度和容量的类型为 T 的切片
make(T, n, m)    分片      	带 n 长度和 m 容量的类型为 T 的切片

make(T)          map        类型为 T 的 map
make(T, n)       map        为约 n 个元素分配了初始化空间的类型为 T 的 map

make(T)          channel    类型为 T 的无缓冲区 channel
make(T, n)       channel    类型为 T 的带缓冲区且缓冲区大小为 n 的 channel
</pre>


<p>
	每个大小实参 <code>n</code> 和 <code>m</code>，必须为整数类型或一个无类型的<a href="#Constants">常量</a>。
	常量大小实参必须是非负的且可被 <code>int</code> 类型值<a href="#Representability">所表示的</a>；如果它是个无类型常量，那么会被给定类型 <code>int</code>。
	如果 <code>n</code> 和 <code>m</code> 都提供了且为常量，那么 <code>n</code> 一定不能大于 <code>m</code>。
	如果在运行时 <code>n</code> 为负值或者大于了 <code>m</code>，那么会发生 <a href="#Run_time_panics">run-time panic</a>。
</p>

<pre>
s := make([]int, 10, 100)       // len(s) == 10, cap(s) == 100 的切片
s := make([]int, 1e3)           // len(s) == cap(s) == 1000 的切片
s := make([]int, 1&lt;&lt;63)         // 非法的: len(s) 不能被 int 类型的值所表示
s := make([]int, 10, 0)         // 非法的: len(s) > cap(s)
c := make(chan int, 10)         // 带大小为 10 的缓冲区的 channel
m := make(map[string]int, 100)  // 带为约 100 个元素初始化空间的 map
</pre>

<p>
	带 map 类型和大小提示 <code>n</code> 来调用 <code>make</code> 会创建一个带持有 <code>n</code> 个 map 元素初始化空间的 map。
	其精度表现是依赖实现的。
</p>


<h3 id="Appending_and_copying_slices">添加和拷贝切片</h3>

<p>
	内置函数 <code>append</code> 和 <code>copy</code> 会协助常见的切片操作。
	对于这两个函数，其结果和实参的内存引用是否重叠无关。
</p>

<p>
	<a href="#Function_types">variadic</a> 函数 <code>append</code> 附加零个或多个值 <code>x</code> 到必须为切片类型的 <code>S</code> 类型的 <code>s</code> ，并返回结果切片，也是 <code>S</code> 类型。
	值 <code>x</code> 是传递给类型为 <code>...T</code> 的一个形参，其中 <code>T</code> 是 <code>S</code> 的<a href="#Slice_types">元素类型</a>并应用对应的<a href="#Passing_arguments_to_..._parameters">参数传递规则</a>。
	作为一个特殊的情况，<code>append</code> 也接受首个为可分配给类型 <code>[]byte</code> 的实参，且第二个为后缀 <code>...</code> 的字符串类型的实参。
	这种形式附加了字符串的字节。
</p>

<pre class="grammar">
append(s S, x ...T) S  // T 是 S 的元素类型
</pre>

<p>
	如果 <code>s</code> 的容量不足以满足额外的值，那么 <code>append</code> 会分配一个新的足够大的底层数组来同时满足已经存在的切片元素和那些额外的值。
	否则，<code>append</code> 复用原来的底层数组。
</p>

<pre>
s0 := []int{0, 0}
s1 := append(s0, 2)                // 附加一个单一元素　 	     s1 == []int{0, 0, 2}
s2 := append(s1, 3, 5, 7)          // 附加多个元素     	     s2 == []int{0, 0, 2, 3, 5, 7}
s3 := append(s2, s0...)            // 附加一个切片     	     s3 == []int{0, 0, 2, 3, 5, 7, 0, 0}
s4 := append(s3[3:6], s3[2:]...)   // 附加重叠的切片　　	     s4 == []int{3, 5, 7, 2, 3, 5, 7, 0, 0}

var t []interface{}
t = append(t, 42, 3.1415, "foo")   //                             t == []interface{}{42, 3.1415, "foo"}

var b []byte
b = append(b, "bar"...)            // 附加字符串内容      		b == []byte{'b', 'a', 'r' }
</pre>

<p>
	函数 <code>copy</code> 从源 <code>src</code> 拷贝切片元素到目的 <code>dst</code> 并返回拷贝的元素个数。
	两个实参必须有<a href="#Type_identity">一致的</a>元素类型 <code>T</code> 并且必须是<a href="#Assignability">可分配</a>给类型为 <code>[]T</code> 的切片的。
	拷贝的元素格式是 <code>len(src)</code> 和 <code>len(dst)</code> 中的最小值。
	作为一个特殊情况，<code>copy</code> 也接受目标实参可分配为 <code>[]byte</code> 类型而源实参为字符串类型。
	这种形式会从字符串中拷贝字节到字节切片中。
</p>

<pre class="grammar">
copy(dst, src []T) int
copy(dst []byte, src string) int
</pre>

<p>
Examples:
</p>

<pre>
var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
var b = make([]byte, 5)
n1 := copy(s, a[0:])            // n1 == 6, s == []int{0, 1, 2, 3, 4, 5}
n2 := copy(s, s[2:])            // n2 == 4, s == []int{2, 3, 4, 5, 4, 5}
n3 := copy(b, "Hello, World!")  // n3 == 5, b == []byte("Hello")
</pre>


<h3 id="Deletion_of_map_elements">map 元素的删除</h3>

<p>
	内置函数 <code>delete</code> 会根据键 <code>k</code> 从 <a href="#Map_types">map</a> <code>m</code> 中删除元素。
	<code>k</code> 的类型必须是<a href="#Assignability">可分配</a>给 <code>m</code> 的键类型的。
</p>

<pre class="grammar">
delete(m, k)  // 从 map m 中删除元素 m[k]
</pre>

<p>
	如果 map <code>m</code> 是 <code>nil</code> 或元素 <code>m[k]</code> 不存在，那么 <code>delete</code> 是一个空操作。
</p>


<h3 id="Complex_numbers">处理复数</h3>

<p>
	有三个函数用来聚合和分解复数。
	内置函数 <code>complex</code> 用浮点的实部和虚部来构造一个复值，而 <code>real</code> 和 <code>imag</code> 从一个复值中提取其实部和虚部。

</p>

<pre class="grammar">
complex(realPart, imaginaryPart floatT) complexT
real(complexT) floatT
imag(complexT) floatT
</pre>

<p>
	实参的类型和返回值对应。
	对于 <code>complex</code>，两个实参必须是相同的浮点类型，并且返回值类型是带对应浮点成分的复合类型，<code>complex64</code> 对应 <code>float32</code> 实参，<code>complex128</code> 对应 <code>float64</code> 实参。
	如果有一个实参求值为一个无类型的常量，那么它会先被隐式地<a href="#Conversions">转换</a>为另一个实参类型。
	如果两个实参都求值为无类型常量，那么它们必须是非复合数或者它们的虚部一定为零，然后函数的返回值也是一个无类型复合常量。
</p>

<p>
	对于 <code>real</code> 和 <code>imag</code>，实参必须是复合类型，返回值是对应的浮点类型：<code>float32</code> 对应一个 <code>complex64</code> 实参，<code>float64</code> 对应一个 <code>complex128</code> 实参。
	如果实参求值为一个无类型常量，那么它必须是一个数，然后函数的返回类型是一个无类型的浮点常量。
</p>

<p>
	<code>real</code> 和 <code>imag</code> 函数一起组成了 <code>complex</code> 的反相，所以对于一个复合类型 <code>Z</code> 的值 <code>z</code> 来说，<code>z&nbsp;==&nbsp;Z(complex(real(z),&nbsp;imag(z)))</code>。
</p>

<p>
	如果这些函数的操作数都是常量，那么返回值也是一个常量。
</p>

<pre>
var a = complex(2, -2)             // complex128
const b = complex(1.0, -1.4)       // 无类型复合常量 1 - 1.4i
x := float32(math.Cos(math.Pi/2))  // float32
var c64 = complex(5, -x)           // complex64
var s int = complex(1, 0)          // 无类型复合常量 1 + 0i 可以被转化为 int
_ = complex(1, 2&lt;&lt;s)               // 非法的： 2 被认为是浮点类型，不能位移
var rl = real(c64)                 // float32
var im = imag(a)                   // float64
const c = imag(b)                  // 无类型常量 -1.4
_ = imag(3 &lt;&lt; s)                   // 法的：3 被认为是复合类型，不能位移
</pre>

<h3 id="Handling_panics">处理 panics</h3>

<p>
	有两个内置函数，<code>panic</code> 和 <code>recover</code>，协助报告和处理 <a href="#Run_time_panics">run-time panics</a> 和程序定义的错误状态。
</p>

<pre class="grammar">
func panic(interface{})
func recover() interface{}
</pre>

<p>
	当执行函数 <code>F</code> 时，对 <code>panic</code> 的明确调用或 <a href="#Run_time_panics">run-time panic</a> 会终止 <code>F</code> 的执行。
	任何被 <code>F</code> <a href="#Defer_statements">推迟</a>的函数会照常执行。
	然后，任何被<code>F</code>的调用者所推迟的函数会运行，以此类推直到被在执行中 goroutine 中的顶层函数所推迟的。
	在这个阶段，程序会终止并且错误状态会被报告，包括给 <code>panic</code> 的实参的值。
	这个终止过程被称为 <i>panicking</i>。
</p>

<pre>
panic(42)
panic("unreachable")
panic(Error("cannot parse"))
</pre>

<p>
	<code>recover</code> 函数允许程序管理一个 panicking goroutine 的行为。
	假设函数 <code>G</code> 推迟调用 <code>recover</code> 的函数 <code>D</code>，且 panic 发生在了和 <code>G</code> 执行的同一个 goroutine 的函数中。
	当运行中的被推迟的函数到达了 <code>D</code> 时，<code>D</code> 对 <code>recover</code> 调用的返回值将是传递给 <code>panic</code> 调用的值。
	如果 <code>D</code> 没有开始一个新的 <code>panic</code>，正常返回，那么 panicking 序列会停止。
	在这种情况中，在 <code>G</code> 和 <code>panic</code> 调用之间的函数状态会被丢弃，然后恢复正常的执行。
	接着会运行被 <code>G</code> 推迟的在 <code>D</code> 前的函数，然后 <code>G</code> 通过返回到它的调用者来终止执行。
</p>

<p>
	如果以下任何条件成立，那么 <code>recover</code> 的返回值为 <code>nil</code>：
</p>
<ul>
<li>
	<code>panic</code> 的实参是 <code>nil</code>；
</li>
<li>
	goroutine 没有 panicking；
</li>
<li>
	<code>recover</code> 没有被一个延迟函数直接调用。
</li>
</ul>

<p>
	在以下例子中的 <code>protect</code> 函数调用了函数实参 <code>g</code> 并使调用者免受 <code>g</code> 中发生的 run-time panic 之害。
</p>

<pre>
func protect(g func()) {
	defer func() {
		log.Println("done")  // 即使这里有 panic，Println 也能正常执行
		if x := recover(); x != nil {
			log.Printf("run time panic: %v", x)
		}
	}()
	log.Println("start")
	g()
}
</pre>


<h3 id="Bootstrapping">引导</h3>

<p>
	目前的实现提供了一些在引导时有用的内置函数。
	这些函数已经被记录完整了但是不能保证会一直存在在语言中。
	它们不会返回一个结果。
</p>

<pre class="grammar">
函数  		行为

print      打印所有实参；实参的格式化和实现有关
println    和 print 类似，但是会在每个实参间打印空格，在结尾打印新行
</pre>

<p>
	实现限制：<code>print</code> 和 <code>println</code> 不需要支持任意的实参类型，但是布尔、数字和字符串<a href="#Types">类型</a>的打印一定要支持。
</p>

<h2 id="Packages">包</h2>

<p>
	Go程序是通过将<i>程序包</i> 链接在一起构造的。
	一个包又由一个或多个源文件构成，这些文件一起声明了属于该包的常量，类型，变量和函数，并且可以在同一包的所有文件中访问它们。
	这些元素可以<a href="#Exported_identifiers">导出</a>并在另一个包中使用。
</p>

<h3 id="Source_file_organization">源文件组织</h3>

<p>
	每个源文件都是由以下组成的：定义其所属包的包子句，一组可能为空的用于声明其想要使用内容的包的导入声明，一组可能为空的函数、类型、变量和常量声明。
</p>

<pre class="ebnf">
SourceFile       = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .
</pre>

<h3 id="Package_clause">包子句</h3>

<p>
	包子句开始了每个源文件，并定义了文件所属的包。
</p>

<pre class="ebnf">
PackageClause  = "package" PackageName .
PackageName    = identifier .
</pre>

<p>
	PackageName 一定不能是<a href="#Blank_identifier">空白标识符</a>。
</p>

<pre>
package math
</pre>

<p>
	共享同一包名的一组文件构成了一个包的实现。
	实现可能要求一个包的源文件都在同一文件夹下。
</p>

<h3 id="Import_declarations">导入声明</h3>

<p>
	导入声明陈述了这个包含声明的源文件依赖<i>被导入的</i> 包的功能（<a href="#Program_initialization_and_execution">程序初始化和执行</a>）并启用了对该包被<a href="#Exported_identifiers">暴露</a>的标识符的访问。
	导入命名了一个标识符（包名）用来被访问，以及一个指定被导入包的导入路径。
</p>

<pre class="ebnf">
ImportDecl       = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .
ImportSpec       = [ "." | PackageName ] ImportPath .
ImportPath       = string_lit .
</pre>

<p>
	PackageName 是用在<a href="#Qualified_identifiers">限定标识符</a>中来访问导入源文件中包的导出标识符。
	它是在<a href="#Blocks">文件块</a>中被声明的。
	如果 PackageName 缺失，那它默认为被导入包的<a href="#Package_clause">包子句</a>中指定的标识符。
	如果明确的句号（<code>.</code>）取代名字出现了，所有在包的<a href="#Blocks">包块</a>中声明的包的暴露标识符将在这个导入包的源文件中被声明，并且必须不带限定符来访问。
</p>

<p>
	导入路径的解释取决于实现，但通常是已编译包的完整文件名的子字符串，并可能和已安装包的库所相对应。
</p>

<p>
	实现限制：编译器可能会限制导入路径仅使用属于 <a href="https://www.unicode.org/versions/Unicode6.3.0/">Unicode's</a> 的 L, M, N, P 和 S 主类的字符串（无空格的可见字符）到非空字符串，并也可能去除了字符串<code>!"#$%&amp;'()*,:;&lt;=&gt;?[\]^`{|}</code> 和 Unicode 替换字符 U+FFFD。
</p>

<p>
	假定我们已经编译了一个包含包子句 <code>package math</code> 的包，它暴露了函数 <code>Sin</code>，并将编译好的包安装在由 <code>"lib/math"</code> 标记的文件。
	此表格说明了 <code>Sin</code> 是如何在在各种导入声明后导入包的文件中被访问的。
</p>

<pre class="grammar">
导入声明        				Sin 的本地名

import   "lib/math"         math.Sin
import m "lib/math"         m.Sin
import . "lib/math"         Sin
</pre>

<p>
	导入声明声明了导入者和被导入包的依赖关系。
	在包中直接或间接导入它自己是非法的，直接导入一个没有引用任何其暴露标识符的包也是非法的。
	仅仅为了包的副作用（初始化）来导入一个包的话，使用<a href="#Blank_identifier">空白</a>标识符作为明确的包名：
</p>

<pre>
import _ "lib/math"
</pre>


<h3 id="An_example_package">一个示例包</h3>

<p>
	这是一个完整的Go包，它实现了并发质数的筛选。
</p>

<pre>
package main

import "fmt"

// 发送 2, 3, 4, … 序列到 channel 'ch'
func generate(ch chan&lt;- int) {
	for i := 2; ; i++ {
		ch &lt;- i  // 发送 'i' 到 channel 'ch'
	}
}

// 从 channel 'src' 拷贝值到 channel 'dst'
// 移除那些可被 'prime' 整除的
func filter(src &lt;-chan int, dst chan&lt;- int, prime int) {
	for i := range src {  // 遍历从 'src' 接收的值
		if i%prime != 0 {
			dst &lt;- i  // 发送 'i' 到 channel 'dst'
		}
	}
}

// 质数筛选: Daisy-chain 过滤器一起处理
func sieve() {
	ch := make(chan int)  // 创建一个新的 channel
	go generate(ch)       // 启动 generate() 作为子进程
	for {
		prime := &lt;-ch
		fmt.Print(prime, "\n")
		ch1 := make(chan int)
		go filter(ch, ch1, prime)
		ch = ch1
	}
}

func main() {
	sieve()
}
</pre>

<h2 id="Program_initialization_and_execution">程序初始化和执行</h2>

<h3 id="The_zero_value">零值</h3>
<p>
	当存储空间被分配给一个<a href="#Variables">变量</a>（无论是通过一个声明、对 <code>new</code> 的调用或是新的值被创建，还是通过一个综合的字面量或对 <code>make</code> 的调用）且没有提供明确的初始化时，这个变量或值会被给定一个默认值。
	这样一个变量或值的每个元素都会被设定到其类型的<i>零值</i>：布尔是 <code>false</code>，数字类型是 <code>0</code>，字符串类型是 <code>""</code>，指针、函数、接口、切片、channel 和 map 类型是 <code>nil</code>。
	初始化会被递归地完成，所以打个比方，如果结构数组的元素未指定值，则都将其每个元素字段置零值。
</p>
<p>
	以下两个简单声明是相等：
</p>

<pre>
var i int
var i int = 0
</pre>

<p>
后
</p>

<pre>
type T struct { i int; f float64; next *T }
t := new(T)
</pre>

<p>
	以下内容成立：
</p>

<pre>
t.i == 0
t.f == 0.0
t.next == nil
</pre>

<p>
	之后也是如此
</p>

<pre>
var t T
</pre>

<h3 id="Package_initialization">包初始化</h3>

<p>
	在一个包内，包级别变量初始化是逐步进行的，每个步骤以<i>声明顺序</i> 选择不依赖未初始化变量的最早变量。
</p>

<p>
	更精确地说，如果包级别变量还没被初始化且其没有<a href="#Variable_declarations">初始化表达式</a>或其初始化表达式没有在未声明变量中有依赖，那么它就被认为是<i>准备好初始化了</i>。
	初始化通过重复初始化下一个最早声明且准备好初始化的包级变量来进行，直到没有变量准备好初始化了。
</p>

<p>
	如果在此过程结束时还有变量没初始化，且这些变量是一个或多个初始化循环的一部分，那么程序是无效的。
</p>

<p>
	由右侧的单个（多值）表达式初始化的变量声明的左侧的多个变量一起被初始化：如果左侧的任何变量被初始化，则所有这些变量都被初始化 在同一步骤中。
</p>

<pre>
var x = a
var a, b = f() // a 和 b 是在 x 被初始化之前一起被初始化的
</pre>

<p>
	为了包初始化的目的，<a href="#Blank_identifier">空白</a>变量会被像其它被描述的变量一样对待。
</p>

<p>
	在多个文件中声明的变量的声明顺序是由对应文件提交给编译器的顺序来决定的：第一个文件中声明的变量会在任何第二个文件中声明的变量之前，以此类推。
</p>

<p>
	依赖性分析不依赖于变量的实际值，而仅依赖于源中对它们进行词法分析的词汇引用。
	例如，如果一个变量 <code>x</code> 的初始化表达式引用了一个其实体引用了变量 <code>y</code> 的函数，那么 <code>x</code> 依赖 <code>y</code>。
	具体来说：
</p>

<ul>
<li>
	该变量或函数的标识符表示的是对变量或函数的引用。
</li>

<li>
	到方法 <code>m</code> 的引用是一个 <code>t.m</code> 形式的<a href="#Method_values">方法值</a>或<a href="#Method_expressions">方法表达式</a>，其中 <code>t</code> 的（静态）类型不能是接口类型，且方法 <code>m</code> 在 <code>t</code> 的方法集中。
	结果的函数值 <code>t.m</code> 是否被调用是无关紧要的。
</li>

<li>
	如果一个变量、函数或方法 <code>x</code> 的初始化表达式或实体（对于函数和方法而言）包含一个到变量 <code>y</code> 或到依赖于 <code>y</code> 的函数或方法的引用，那么 <code>x</code> 是依赖 <code>y</code> 的。
</li>
</ul>

<p>
	比如，给定声明
</p>

<pre>
var (
	a = c + b  // == 9
	b = f()    // == 4
	c = f()    // == 5
	d = 3      // == 5 初始化结束后等于 5
)

func f() int {
	d++
	return d
}
</pre>

<p>
	初始化顺序是 <code>d</code>，<code>b</code>，<code>c</code>，<code>a</code>。
	注意的是，初始化表达式中的子表达式的顺序是无所谓的：示例中 <code>a = c + b</code> 和 <code>a = b + c</code> 得出的是相同的初始化顺序。
</p>

<p>
	依赖分析是分包执行的；只有涉及到在当前包中声明的变量、函数和（非接口）方法的引用才会被考虑。
	如果变量间存在其它、隐藏的、数据依赖，那么这些变量间的初始化顺序是不明的。
</p>

<p>
	比如，给定声明
</p>

<pre>
var x = I(T{}).ab()   // x 存在在 a 和 b 上的未被发现的隐藏依赖
var _ = sideEffect()  // 与 x, a, 或 b 无关
var a = b
var b = 42

type I interface      { ab() []int }
type T struct{}
func (T) ab() []int   { return []int{a, b} }
</pre>

<p>
	变量 <code>a</code> 会在 <code>b</code> 后被初始化，但是 <code>x</code> 是在 <code>b</code> 之前、在 <code>b</code> 和 <code>a</code> 之间、还是在 <code>a</code> 之后，以及 <code>sideEffect()</code> 会在什么时候被调用（在 <code>x</code> 初始化前还是后）都是不明的。
</p>

<p>
	变量也可以被包块中声明的不带实参和结果类型的名为 <code>init</code> 的函数所初始化。
</p>

<pre>
func init() { … }
</pre>

<p>
	单一包中可以定义多个这样的函数，甚至是在单一源文件内也没问题。
	在包块内，<code>init</code> 标识符仅用于声明 <code>init</code> 函数，但标识符本身是未<a href="#Declarations_and_scope">声明的</a>。
	这样的 <code>init</code> 函数不能在程序中的任何位置被引用。
</p>

<p>
	不带导入声明的包是这样初始化的：分配初始化值到它所有的包级变量（按照出现在源码中的顺序，可能会在多个文件中，那就按照提交到编译器的顺序），接着调用 <code>init</code> 函数。
	如果包有导入声明，那么在初始化包本身之前，被导入的包会先初始化好。
	如果多个包导入了一个包，那么被导入的包只会初始化一次。
	通过构造可以保证包的导入不存在循环初始化依赖关系。
</p>

<p>
	包的初始化（变量初始化和对 <code>init</code> 函数的调用）在单一 goroutine 内，循序的，每次一个包地发生。
	<code>init</code> 函数可能发起其它的可以与初始化代码并行运行的 goroutine。
	不过，初始化过程总是会序列化 <code>init</code> 函数：在上一个没有返回前不会调用下一个。
</p>

<p>
	为了确保可重现的初始化行为，建议构建系统以词法文件名顺序将属于同一个包的多个文件呈现给编译器。
</p>


<h3 id="Program_execution">程序执行</h3>
<p>
	一个完整的程序是通过按轨迹地连接一个单一的，未导入的被叫做 <i>main package</i> 的包与其它所有其导入的包来创建的。
	主包的包名一定是 <code>main</code>，并且声明一个无实参也无返回值的 <code>main</code> 函数。
</p>

<pre>
func main() { … }
</pre>

<p>
	程序通过先初始化主包再调用 <code>main</code> 函数来开始执行。
	当这个函数调用返回时，程序退出。
	并不会等待其它（非 <code>main</code>）goroutine 完成。
</p>

<h2 id="Errors">错误</h2>

<p>
	预先声明的类型 <code>error</code> 定义如下：
</p>

<pre>
type error interface {
	Error() string
}
</pre>

<p>
	它是表示错误条件的常见接口，nil 值代表没有错误。
	例如，从文件读入数据的函数可能被定义为：
</p>

<pre>
func Read(f *File, b []byte) (n int, err error)
</pre>

<h2 id="Run_time_panics">Run-time panics</h2>

<p>
	像尝试超出数组边界的索引这样的执行错误会触发一个 <i>run-time panic</i>，它等同于对内置函数 <a href="#Handling_panics"><code>panic</code></a> 的调用，该调用使用根据实现定义的接口类型 <code>runtime.Error</code> 的值作为实参。
	这个类型满足预先声明的接口类型 <a href="#Errors"><code>error</code></a>。
	表示不同运行时错误条件的确切错误值是为指定的。
</p>

<pre>
package runtime

type Error interface {
	error
	// 或许还有其它方法
}
</pre>

<h2 id="System_considerations">系统注意事项</h2>

<h3 id="Package_unsafe">包 <code>unsafe</code></h3>

<p>
	编译器已知且可以通过<a href="#Import_declarations">导入路径</a> <code>"unsafe"</code> 访问的内置包 <code>unsafe</code> 提供了包括违反类型系统操作在内的低级编程设施。
	使用 <code>unsafe</code> 的包必须必须手动审查以确保类型安全，且不具备可移植性。
	该包提供了以下接口：
</p>

<pre class="grammar">
package unsafe

type ArbitraryType int  // 任意 Go 类型的简写；它不是一个真实的类型
type Pointer *ArbitraryType

func Alignof(variable ArbitraryType) uintptr
func Offsetof(selector ArbitraryType) uintptr
func Sizeof(variable ArbitraryType) uintptr
</pre>

<p>
	<code>Pointer</code> 是一个<a href="#Pointer_types">指针类型</a>但是 <code>Pointer</code> 值不能被<a href="#Address_operators">解引用</a>。
	任何指针或<a href="#Types">潜在类型</a>为 <code>uintptr</code> 的值都可以被转换为潜在类型为 <code>Pointer</code> 的类型，反之亦然。
	在 <code>Pointer</code> 和 <code>uintptr</code> 间的转换效果是由实现定义的。
</p>

<pre>
var f float64
bits = *(*uint64)(unsafe.Pointer(&amp;f))

type ptr unsafe.Pointer
bits = *(*uint64)(ptr(&amp;f))

var p ptr = nil
</pre>

<p>
	函数 <code>Alignof</code> 和 <code>Sizeof</code> 获取任意类型的表达式 <code>x</code> 并分别返回假设变量 <code>v</code> 的定位或大小（<code>v</code> 就像通过 <code>var v = x</code> 声明的一样）。
</p>
<p>
	函数 <code>Offsetof</code> 获取一个（可能被括起来的）表示被 <code>s</code> 或 <code>*s</code> 所表示的结构体的字段 <code>f</code> 的<a href="#Selectors">选择器</a> <code>s.f</code>，并返回相对于结构体地址的以字节表示的字段的偏移量。
	如果 <code>f</code> 是一个<a href="#Struct_types">嵌入字段</a>，那么必须可以在不要指针间接情况下直达结构体字段。
	对于带字段 <code>f</code> 的结构体 <code>s</code>：
</p>

<pre>
uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f) == uintptr(unsafe.Pointer(&amp;s.f))
</pre>

<p>
	计算机架构可能会要求内存地址是<i>对齐的</i>；也就是说，变量的地址是一个因子的倍数，这个因子是变量类型的<i>对准值</i>。
	函数 <code>Alignof</code> 获取一个表示任意类型变量的表达式，并以字节为单位返回变量（的类型）的对准值。对于一个变量 <code>x</code>：
</p>

<pre>
uintptr(unsafe.Pointer(&amp;x)) % unsafe.Alignof(x) == 0
</pre>

<p>
	对于 <code>Alignof</code>、<code>Offsetof</code>、<code>Sizeof</code> 的调用是类型 <code>uintptr</code> 的编译时常量表达式。
</p>

<h3 id="Size_and_alignment_guarantees">大小和对准值保证</h3>

<p>
	对于<a href="#Numeric_types">数字类型</a>，以下大小是保证的：
</p>

<pre class="grammar">
type                                 size in bytes

byte, uint8, int8                     1
uint16, int16                         2
uint32, int32, float32                4
uint64, int64, float64, complex64     8
complex128                           16
</pre>

<p>
	以下最小对准值属性是保证的：
</p>
<ol>
<li>对于任意类型变量 <code>x</code>：<code>unsafe.Alignof(x)</code> 最小为 1。
</li>

<li>对于结构体类型变量 <code>x</code>：<code>unsafe.Alignof(x)</code> 是所有 <code>unsafe.Alignof(x.f)</code>（对于 <code>x</code> 的每个字段 <code>f</code>）中最大的值，但最小为1。
</li>

<li>对于数组类型变量 <code>x</code>：<code>unsafe.Alignof(x)</code> 和数组元素类型变量的对准值相同。
</li>
</ol>

<p>
	如果结构体或数组没有包含大于零大小的字段（或元素，对数组而言），那么它大大小为零。
	两个不同的零大小的变量在内存中可能拥有同一个地址。
</p>
